<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL</title>
    <url>/2020/06/29/STL/</url>
    <content><![CDATA[<p>本篇博文应该归类于Cpp语言部分，但是我太懒了，不想去找图片，添加一些东西emmm</p>
<h1 id="vector-动态数组-倍增思想"><a href="#vector-动态数组-倍增思想" class="headerlink" title="vector:动态数组,倍增思想"></a>vector:动态数组,倍增思想</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">包含于头文件 #include &lt;vector&gt;</div><div class="line">定义一个数组:vector&lt;Type&gt;v:Type是数据类型</div><div class="line">vector&lt;int&gt;v[N]</div><div class="line">固定的一维是N,第二维是动态的</div></pre></td></tr></table></figure>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">v.push_back(i):在尾部增加元素</div><div class="line">v.size():元素个数</div><div class="line">v.empty():判断是否位空。空返回ture,非空返回false</div><div class="line">v.insert(v.begin()+i,k):在第i个元素前面插入k</div><div class="line">v.insert(v.end(),10,5):尾部插入10个值为5的元素</div><div class="line">v.pop_back(i):删除尾部元素</div><div class="line">v.erase(v.begin()+i,v.begin()+j):删除区间[i,j)的元素</div><div class="line">v.erase(v.begin()+2):删除第三个元素</div><div class="line">v.clear():清空数组</div><div class="line">v.resize(n):数组大小变为n</div><div class="line">reverse(v.begin(),v.end()):翻转数组</div><div class="line">sort(v.begin(),v.end()):从小到大排序</div><div class="line">[]</div><div class="line">支持比较运算,按字典序</div></pre></td></tr></table></figure>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pair&lt;Type,type&gt; P,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">P.first:取第一个元素</div><div class="line">P.second:取第二个元素</div></pre></td></tr></table></figure>
<h1 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string:字符串"></a>string:字符串</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string s;</div></pre></td></tr></table></figure>
<h2 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s = &quot;&quot;;清空操作</div><div class="line">getline(cin,s):输入含有空格的字符串</div><div class="line">s.size()/s.length():返回字符串长度</div><div class="line">s.empty():判断是否为空</div><div class="line">s.clear():清空</div><div class="line">substr(起始下标,(子串长度)):返回子串,若省略子串长度,返回起始下标到字符串结束</div><div class="line">s_str():返回字符串所在字符数组的起始地址</div></pre></td></tr></table></figure>
<h1 id="stack-先进后出"><a href="#stack-先进后出" class="headerlink" title="stack:先进后出"></a>stack:先进后出</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">包含于头文件 #include &lt;stack&gt;</div><div class="line">定义一个栈 stack&lt;Type&gt; s,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s.push(i)：把i加入栈顶</div><div class="line">s.top()：返回栈顶元素</div><div class="line">s.pop()：弹出栈顶元素</div><div class="line">s.size()：返回栈中的元素个数</div><div class="line">s.empty()：判断栈是否为空，空返回true,非空返回false</div></pre></td></tr></table></figure>
<h1 id="queue：先进先出"><a href="#queue：先进先出" class="headerlink" title="queue：先进先出"></a>queue：先进先出</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">包含于头文件 #include &lt;queue&gt;</div><div class="line">定义一个队列 queue&lt;Type&gt; q,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">q.push(i):把i放进队列</div><div class="line">q.front():返回队首元素</div><div class="line">q.pop():删除队首元素</div><div class="line">q.back():返回队尾元素</div><div class="line">q.size():返回元素个数</div><div class="line">q.empty():判断队列是否为空,空返回true,非空返回false</div></pre></td></tr></table></figure>
<h1 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque:双端队列"></a>deque:双端队列</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">包含于头文件 #include &lt;deque&gt;</div><div class="line">deque&lt;Type&gt; D;</div></pre></td></tr></table></figure>
<h2 id="常用操作-4"><a href="#常用操作-4" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D.size():返回元素个数</div><div class="line">D.empty():判断是否为空</div><div class="line">D.clear():清空</div><div class="line">D.front():返回第一个元素</div><div class="line">D.back():返回最后一个元素</div><div class="line">D.push_back(i):在尾部插入i</div><div class="line">D.pop_back():队尾弹出最后一个数</div><div class="line">D.push_front(i):队首插入一个数i</div><div class="line">D.pop_front():队首弹出一个数</div><div class="line">D.begin():迭代器开始</div><div class="line">D.end():迭代器结束</div><div class="line">[]:随机选取</div></pre></td></tr></table></figure>
<h1 id="priority-queue-优先级高的先出队。"><a href="#priority-queue-优先级高的先出队。" class="headerlink" title="priority_queue:优先级高的先出队。"></a>priority_queue:优先级高的先出队。</h1><h2 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">包含于头文件 #include &lt;queue&gt;</div><div class="line">定义一个优先队列 priority_queue&lt;Type&gt; p,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作-5"><a href="#常用操作-5" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">p.top():返回具有优先级高的元素值</div><div class="line">p.pop():删除最高优先级的元素</div><div class="line">p.push(i):插入新元素</div><div class="line">定义成小根堆:priority_queue&lt;Type,vector&lt;Type&gt;,greater&lt;Type&gt;&gt; Q;</div><div class="line">priority_queue&lt;Type&gt; heap; heap.push(-x);</div><div class="line">无clear()函数</div></pre></td></tr></table></figure>
<h1 id="list-存储空间不连续-双向链表"><a href="#list-存储空间不连续-双向链表" class="headerlink" title="list:存储空间不连续,双向链表"></a>list:存储空间不连续,双向链表</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vector:插入和删除操作少,随机访问元素频繁</div><div class="line">list:插入和删除频繁,随机访问少</div><div class="line">list&lt;Type&gt;L,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作-6"><a href="#常用操作-6" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">L.push_back(i):赋值</div><div class="line">L.erase(i):删除i</div></pre></td></tr></table></figure>
<h1 id="set-集合中的元素是排好序并且只出现一次"><a href="#set-集合中的元素是排好序并且只出现一次" class="headerlink" title="set:集合中的元素是排好序并且只出现一次"></a>set:集合中的元素是排好序并且只出现一次</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">访问元素的时间复杂度O(logn)</div><div class="line">set&lt;Type&gt; s,Type是数据类型</div></pre></td></tr></table></figure>
<h2 id="常用操作-set-multiset-允许重复元素"><a href="#常用操作-set-multiset-允许重复元素" class="headerlink" title="常用操作 set/multiset(允许重复元素)"></a>常用操作 set/multiset(允许重复元素)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s.insert(i):把i放进集合s</div><div class="line">s.erase(i):删除元素i</div><div class="line">(1):输入一个数i,删除所以i,O(k+logn),k为i的个数</div><div class="line">(2):输入一个迭代器,删除这个迭代器</div><div class="line">s.clear():清空集合s</div><div class="line">s.empty():判断是否为空,空返回true,非空返回false</div><div class="line">s.size():返回元素个数</div><div class="line">s.find(k):查找k,若没找到返回end(),找到返回指向k的迭代器</div><div class="line">s.lower_bound(k):返回一个迭代器,指向键值不小于k的第一个元素</div><div class="line">s.upper_bound():返回一个迭代器,指向键值大于k的第一个元素</div></pre></td></tr></table></figure>
<h1 id="map-关联容器-查找的时间复杂度O-logn"><a href="#map-关联容器-查找的时间复杂度O-logn" class="headerlink" title="map:关联容器,查找的时间复杂度O(logn)"></a>map:关联容器,查找的时间复杂度O(logn)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">map&lt;string,int&gt; mp,存储string类型和int类型,第一个是key,第二个是value</div><div class="line">赋值:mp[&quot;Tom&quot;] = 15</div></pre></td></tr></table></figure>
<h2 id="常用操作-map-multimap"><a href="#常用操作-map-multimap" class="headerlink" title="常用操作:map/multimap"></a>常用操作:map/multimap</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">insert():插入的数是pair类型</div><div class="line">find():查找一个数,不存在返回迭代器end()</div><div class="line">count():返回某一个数的个数。</div><div class="line">erase():</div><div class="line">(1):输入一个数i,删除所以i,O(k+logn),k为i的个数</div><div class="line">(2):输入一个迭代器,删除这个迭代器</div><div class="line">[]:multimap不支持此操作,O(logn)</div><div class="line">lower_bound(k):返回一个迭代器,指向键值不小于k的第一个元素</div><div class="line">upper_bound():返回一个迭代器,指向键值大于k的第一个元素</div></pre></td></tr></table></figure>
<h1 id="set-map-multiset-multimap-基于平衡二叉树-动态维护有序序列"><a href="#set-map-multiset-multimap-基于平衡二叉树-动态维护有序序列" class="headerlink" title="set,map,multiset,multimap:基于平衡二叉树,动态维护有序序列"></a>set,map,multiset,multimap:基于平衡二叉树,动态维护有序序列</h1><h2 id="都支持的操作"><a href="#都支持的操作" class="headerlink" title="都支持的操作:"></a>都支持的操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   size():O(1)</div><div class="line">   empty():O(1)</div><div class="line">   clear()</div><div class="line">   begin()/end()</div><div class="line">   ++,--:返回前驱和后继,O(logn)</div><div class="line">undered_set,undered_map,undered_multiset,undered_multimap,哈希表</div><div class="line">和上面类似,增删改查的时间复杂度是O(1)</div><div class="line">不支持 lower_bound()/upper_bound(),迭代器++,--</div></pre></td></tr></table></figure>
<h1 id="bitset-压位-1kb-1024b"><a href="#bitset-压位-1kb-1024b" class="headerlink" title="bitset:压位 1kb=1024b"></a>bitset:压位 1kb=1024b</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bitset&lt;10000&gt; s:定义长度为1万的bitset,10000b</div></pre></td></tr></table></figure>
<h2 id="常用操作-7"><a href="#常用操作-7" class="headerlink" title="常用操作:"></a>常用操作:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">~,&amp;,|,^</div><div class="line">&gt;&gt;,&lt;&lt;</div><div class="line">==,!=</div><div class="line">[]:取某一位</div><div class="line">count():返回多少个1</div><div class="line">any():判断是否至少有一个1</div><div class="line">none():判断是否全为0</div><div class="line">set():把所有位置成1</div><div class="line">set(k,v):将第k位置成v</div><div class="line">reset():把所以位变成0</div><div class="line">flip():等价于~</div><div class="line">flip(k):把第k位按位取反</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2020/06/29/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/HDU-1556" target="_blank" rel="external">题目链接</a></p>
<h1 id="涂气球"><a href="#涂气球" class="headerlink" title="涂气球"></a><font size="5">涂气球</font></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h2><p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h2><p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h2><p>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 2<br>1 3<br>0</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a><font size="5">样例输出</font></h2><p>1 1 1<br>3 2 1</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="Blue">差分</font>,对于区间操作,每次会把区间[L,R]之间的所有气球涂一次,那么就让a[L]++,a[r+1]–,再求一次前缀和就可以得出答案。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int a[maxn],b[maxn];</div><div class="line">int x,y,n;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</div><div class="line">    &#123;</div><div class="line">        memset(a,0,sizeof(a));</div><div class="line">        for(int i=1;i&lt;=n;++i)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</div><div class="line">            if(x&gt;y) swap(x,y);</div><div class="line">            a[x]++;a[y+1]--;</div><div class="line">        &#125;</div><div class="line">        for(int i=1;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            b[i]=b[i-1]+a[i];</div><div class="line">            if(i!=n) printf(&quot;%d &quot;,b[i]);</div><div class="line">            else printf(&quot;%d&quot;,b[i]);</div><div class="line">        &#125;</div><div class="line">        puts(&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/999/A" target="_blank" rel="external">题目链接</a></p>
<h1 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a><font size="5">激光炸弹</font></h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。<br>现在地图上有n(N ≤ 10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。<br>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。<br>若目标位于爆破正方形的边上，该目标将不会被摧毁。 </p>
<h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h2><p>输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示 x,y ,v。</p>
<h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h2><p>输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标(结果不会超过32767)。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h2><p>2 1<br>0 0 1<br>1 1 1</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a><font size="5">样例输出</font></h2><p>1</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p>二维前缀和,sum[x][y]就等于位置(x,y)上的所有目标的价值之和。求一下sum[x][y]的二维前缀和S。</p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</div><div class="line">using namespace std;</div><div class="line">const int N=5e3+7;</div><div class="line">int sum[N][N],a[N][N];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,r;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;r);</div><div class="line">    int x,y,v,rx=r,ry=r;</div><div class="line">    while(n--)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;v);</div><div class="line">        x++,y++;</div><div class="line">        a[x][y]=v;</div><div class="line">        rx=max(x,rx);</div><div class="line">        ry=max(y,ry);</div><div class="line">    &#125;</div><div class="line">    rep(i,1,rx)</div><div class="line">        rep(j,1,ry)</div><div class="line">            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];</div><div class="line">    int ans=0;</div><div class="line">    rep(i,r,rx)</div><div class="line">        rep(j,r,ry)</div><div class="line">            ans=max(ans,sum[i][j]-sum[i-r][j]-sum[i][j-r]+sum[i-r][j-r]);</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/999/B" target="_blank" rel="external">题目链接</a></p>
<h1 id="IncDec-Sequence"><a href="#IncDec-Sequence" class="headerlink" title="IncDec Sequence"></a><font size="5">IncDec Sequence</font></h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>给定一个长度为 n(n&lt;=1e5)的数列 a1, a2, …, an,每次可以选择一个区间 [l,r],使下标在这个区间内的数都加一或者都减一。<br>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
<h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h2><p>第一行一个整数n<br>接下来 n 行,每行一个整数,第 i+1 行的整数表示 ai。</p>
<h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h2><p>第一行输出最少操作次数。<br>第二行输出最终能得到多少种结果。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h2><p>4<br>1<br>1<br>2<br>2</p>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a><font size="5">样例输出</font></h2><p>1<br>2</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p>求出序列 a 的差分序列 b, b[1]=a[1],b[i]=a[i]-a<a href="2&lt;=i&lt;=n">i-1</a>。b[n+1]=0。题目对于序列 a 的操作,相当于每次从序列 b 中选出任意两个数,一个加 1,另一个减 1。目标把 b[2]…b[n]变为全0。最后得到的数列 a 就是由 n 个 b[1]构成。<br>从差分序列中选取任意两个数的方法可分为四类:</p>
<p><font size="4" color="Blue">1.选取 b[i] 和 b[j] (2&lt;=i,j&lt;=n)。会改变b[2]…b[n]中两个数的值。应该在保证b[i]和b[j]一正一负的前提下,尽量采取这种操作,更快地接近目标。</font></p>
<p><font size="4" color="Blue">2.选取b[1]和b[j] (2&lt;=j&lt;=n)</font></p>
<p><font size="4" color="Blue">3.选取b[i]和b[n+1] (2&lt;=i&lt;=n)</font></p>
<p><font size="4" color="Blue">4.选取b[1]和b[n+1],永远不会改变b[2]…b[n]的值,相当于浪费一次操作,一定不是最优解。</font></p>
<p><font size="4" color="Green">设b[2],b[3]…b[n]中正数总和为p,负数总和的绝对值是q。首先用正负数配对的方式执行第1类操作,可执行min(p,q)次。剩余|p-q|个没有配对,对每个可以选择与b[1]或b[n+1]配对,就是执行第2类或第3类操作,共需|p-q|次</font></p>
<p><font size="4" color="red">综上所述,最少操作次数就是min(p,q)+|p-q|=max(p,q)次。根据|p-q|次第2、3类操作的选择情况,能产生|p-q|+1种不同的b[1]的值,就是最后得到的序列a可能有|p-q|+1种。</font></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N=1e5+7;</div><div class="line">int a[N],b[N];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line">    ll p=0,q=0;</div><div class="line">    for(int i=1;i&lt;=n;++i) </div><div class="line">    &#123;</div><div class="line">        b[i]=a[i]-a[i-1];</div><div class="line">        if(i&gt;1)</div><div class="line">        &#123;</div><div class="line">            if(b[i]&gt;0) p+=b[i];</div><div class="line">            else q-=b[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%lld\n%lld\n&quot;,max(p,q),abs(p-q)+1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/999/C" target="_blank" rel="external">题目链接</a></p>
<h1 id="Tallest-Cow"><a href="#Tallest-Cow" class="headerlink" title="Tallest Cow"></a><font size="5">Tallest Cow</font></h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>有 N 头牛站成一行。两头牛能够互相看见,当且仅当它们中间的牛身高都比它们矮。现在,我们只知道其中最高的两头牛是第p头,它的身高是 H,不知道剩余 N-1 头牛的身高。但是,我们还知道 M 对关系,每对关系都指明了某两头牛A[i]和B[i]可以互相看见。求每头牛的身高最大可能是多少。<br>数据范围: 1&lt;=N,M&lt;=1e4, 1&lt;=H&lt;=1e6。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">对一个区间的操作转化为左右两个端点的操作,</font></p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=1e4+7;</div><div class="line">int a[maxn],b[maxn],vis[maxn][maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,num,h,r,x,y;</div><div class="line">    scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;num,&amp;h,&amp;r);  // n头牛,最高的牛的位置是num,身高是h,有 r 对关系</div><div class="line">    for(int i=1;i&lt;=r;++i)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</div><div class="line">        if(x&gt;y) swap(x,y);</div><div class="line">        if(!vis[x][y]) a[x+1]--,a[y]++;  //去除重复的关系&amp;&amp;差分</div><div class="line">        vis[x][y]=1;  //标记出现过</div><div class="line">    &#125;</div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        b[i]=b[i-1]+a[i];  //前缀和</div><div class="line">        printf(&quot;%d\n&quot;,b[i]+h);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2020/06/29/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/996/B" target="_blank" rel="external">题目链接</a></p>
<h1 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>有T组测试，每组测试输入一个模数p，输入有H组数据，每组数据有a,b, 求a^b%p，各组数据的和再模p。<br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">快速幂</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 5000;</div><div class="line">int t,h;</div><div class="line">ll mod,a[N],b[N];</div><div class="line">ll quick_mi(ll a, ll b, ll p)//a:底数 b:指数 p:模数</div><div class="line">&#123;</div><div class="line">    int res=1%p;</div><div class="line">    while(b)</div><div class="line">    &#123;</div><div class="line">        if(b&amp;1) res=a*res%p;</div><div class="line">        a=a*a%p;</div><div class="line">        b&gt;&gt;=1;</div><div class="line">    &#125;</div><div class="line">    return res%p;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);</div><div class="line">    std::cout.tie(0);</div><div class="line">    std::cin&gt;&gt;t;</div><div class="line">    while(t--)</div><div class="line">    &#123;</div><div class="line">        int ans=0;</div><div class="line">        std::cin&gt;&gt;mod&gt;&gt;h;  //模数mod，H组数据</div><div class="line">        for(int i=1;i&lt;=h;++i) </div><div class="line">        &#123;</div><div class="line">            std::cin&gt;&gt;a[i]&gt;&gt;b[i];</div><div class="line">            ans=(ans%mod+quick_mi(a[i],b[i],mod))%mod;</div><div class="line">        &#125;</div><div class="line">        std::cout&lt;&lt;ans&lt;&lt;&apos;\n&apos;;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/996/A" target="_blank" rel="external">题目链接</a></p>
<h1 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a>a^b</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>求 a 的 b 次方对 p 取模的值，其中 0≤a,b,p≤1e9</em></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font color="red" size="4">快速幂</font></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font>AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">ll a,b,mod;</div><div class="line">ll quick_mi(ll a, ll b, ll mod) //a表示底数，b表示指数</div><div class="line">&#123;</div><div class="line">    ll res=1%mod;</div><div class="line">    while(b)</div><div class="line">    &#123;</div><div class="line">        if(b&amp;1) res=res*a%mod;</div><div class="line">        a = a*a%mod;</div><div class="line">        b&gt;&gt;=1;</div><div class="line">    &#125;</div><div class="line">    return res%mod;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);</div><div class="line">    cout.tie(0);</div><div class="line">    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</div><div class="line">    std::cout&lt;&lt;quick_mi(a,b,mod)&lt;&lt;&apos;\n&apos;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/996/C" target="_blank" rel="external">题目链接</a></p>
<h1 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a>64位整数乘法</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>求a乘b对p取模的值，其中1≤a,b,p≤1e18</em></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">基于快速幂思想的快速乘</font></p>
<p><font size="4" color="bule"><br>    axb=a+a+a+a+……a<br>    ax1=a<br>    ax2=2a<br>    ax4=4a<br>    ax8=8a<br>    ……<br>    ax(2^k)=2^kxa<br>    时间复杂度(O(logb))<br></font></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font>AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">ll a,b,p;</div><div class="line">void work(ll a, ll b, ll mod)</div><div class="line">&#123;</div><div class="line">    ll ans=0;</div><div class="line">    while(b)</div><div class="line">    &#123;</div><div class="line">        if(b&amp;1) ans=(ans+a)%mod;</div><div class="line">        a=a*2%mod;</div><div class="line">        b&gt;&gt;=1;</div><div class="line">    &#125;</div><div class="line">    std::cout&lt;&lt;ans%p&lt;&lt;&apos;\n&apos;;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);</div><div class="line">    std::cout.tie(0);</div><div class="line">    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;</div><div class="line">    work(a,b,p);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/998/F" target="_blank" rel="external">题目链接</a></p>
<h1 id="Sumdiv"><a href="#Sumdiv" class="headerlink" title="Sumdiv"></a>Sumdiv</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><h2 id="求A的B次方的所有约数之和，取余9901-1-lt-A-B-lt-5e7"><a href="#求A的B次方的所有约数之和，取余9901-1-lt-A-B-lt-5e7" class="headerlink" title="求A的B次方的所有约数之和，取余9901(1&lt;=A,B&lt;=5e7)"></a><em>求A的B次方的所有约数之和，取余9901(1&lt;=A,B&lt;=5e7)</em></h2><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><img src="http://edviv.gitee.io/images_bed/images/ACM/Sumdiv.jpg" alt=""></p>
<h2 id="AC代码-gt"><a href="#AC代码-gt" class="headerlink" title="AC代码&gt;"></a><font size="5">AC代码</font>&gt;</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</div><div class="line">using namespace std;</div><div class="line">const int mod=9901;</div><div class="line">int quick_mi(int a, int b)</div><div class="line">&#123;</div><div class="line">    int res=1; a=a%mod;</div><div class="line">    while(b)</div><div class="line">    &#123;</div><div class="line">        if(b&amp;1) res=res%mod*a%mod;</div><div class="line">        a=a*a%mod;</div><div class="line">        b&gt;&gt;=1;</div><div class="line">    &#125;</div><div class="line">    return res%mod;</div><div class="line">&#125;</div><div class="line">int sum(int p,int k)</div><div class="line">&#123;</div><div class="line">    if(k==0) return 1;</div><div class="line">    if(k&amp;1) return ((1+quick_mi(p,(k+1)&gt;&gt;1))*sum(p,(k-1)&gt;&gt;1))%mod;</div><div class="line">    else return ((1+quick_mi(p,k&gt;&gt;1))*sum(p,(k&gt;&gt;1)-1)%mod+quick_mi(p,k))%mod;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int A,B,ans=1;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;A,&amp;B);</div><div class="line">    rep(i,2,A)</div><div class="line">    &#123;</div><div class="line">        int cnt=0;</div><div class="line">        while(A%i==0)</div><div class="line">        &#123;</div><div class="line">            cnt++;</div><div class="line">            A/=i;</div><div class="line">        &#125;</div><div class="line">        if(cnt) ans=ans*sum(i,cnt*B)%mod;</div><div class="line">    &#125;</div><div class="line">    if(A==0) puts(&quot;0&quot;);</div><div class="line">    else printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/06/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="Disjoin-Set"><a href="#Disjoin-Set" class="headerlink" title="Disjoin-Set"></a><font size="5">Disjoin-Set</font></h1><font size="4" color="red">并查集:</font><font size="4" color="Green">是一种可以动态维护若干个不重叠的集合,支持合并和查询的数据结构。</font>

<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a><font size="5">存储</font></h2><p>定义一个 fa 数组保存父节点,根的父节点设为自己。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int fa[size];</div></pre></td></tr></table></figure></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font size="5">初始化</font></h2><p>设有 n 个元素,起初所有元素各自构成一个独立的集合,即有 n 棵 1 个点的树。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i=1;i&lt;=n;++i) fa[i]=i;</div></pre></td></tr></table></figure></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a><font size="5">查询</font></h2><p>若 x 是树根,则 x 就是集合代表,否则递归查询 fa[x] 直至根节点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int findroot(int x)</div><div class="line">&#123;</div><div class="line">	if(x==fa[x]) return x;</div><div class="line">	return fa[x]=findroot(fa[x]);    //路径压缩, fa 直接赋值为代表元素</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a><font size="5">合并</font></h2><p>合并元素 x 和 元素y 所在的集合,等价于让 x 的树根作为 y 树根的子节点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void merge(int x,int y)</div><div class="line">&#123;</div><div class="line">	int fax=findroot(x);</div><div class="line">	int fay=findroot(y);</div><div class="line">	fa[fax]=fay;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a><font size="5">习题</font></h1><h2 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a><font size="5">连通块中点的数量</font></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h3><p>给定一个包含n个点（编号为1 $\sim$ n）的无向图,初始时图中没有边。现在要进行m个操作,操作共有三种:“C a b”,点a和点b之间连一条边,a和b可能相等;“Q1 a b”,询问点a和点b是否在同一个连通块中,a和b可能相等;“Q2 a”,询问点a所在连通块中点的数量;</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h3><p>第一行输入整数n和m。接下来m行,每行包含一个操作指令,指令为“C a b”,“Q1 a b”或“Q2 a”中的一种。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h3><p>对于每个询问指令”Q1 a b”,如果a和b在同一个连通块中,则输出“Yes”,否则输出“No”。对于每个询问指令“Q2 a”,输出一个整数表示点a所在连通块中点的数量;每个结果占一行。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">5 5</div><div class="line">C 1 2</div><div class="line">Q1 1 2</div><div class="line">Q2 1</div><div class="line">C 2 5</div><div class="line">Q2 5</div></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Yes</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h3><font size="4" color="red">并查集,开个数组记录根节点有多少个元素</font>

<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int fa[maxn],n,m,Size[maxn];</div><div class="line">char op[5];</div><div class="line">void init()  //初始化</div><div class="line">&#123;</div><div class="line">    for(int i=1;i&lt;=maxn;i++) fa[i]=i,Size[i]=1;</div><div class="line">&#125;</div><div class="line">int findroot(int x)   //查询 返回 x 的祖宗节点 + 路径压缩</div><div class="line">&#123;</div><div class="line">    if(x==fa[x]) return x;    //x 是根节点 返回父节点</div><div class="line">    return fa[x]=findroot(fa[x]);    // x 不是根节点, 就让它的父节点等于祖宗节点</div><div class="line">&#125;</div><div class="line">void merge(int a,int b)   //合并</div><div class="line">&#123;</div><div class="line">    int ta=findroot(a);</div><div class="line">    int tb=findroot(b);</div><div class="line">    if(ta != tb)</div><div class="line">    &#123;</div><div class="line">        fa[ta]=tb;    // b是 a 的根  </div><div class="line">        Size[tb]+=Size[ta];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    init();</div><div class="line">    scanf(&quot; %d%d&quot;,&amp;n,&amp;m);</div><div class="line">    while(m--)</div><div class="line">    &#123;</div><div class="line">        int a,b;</div><div class="line">        scanf(&quot; %s&quot;,op);</div><div class="line">        if(op[0]==&apos;C&apos;)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot; %d%d&quot;,&amp;a,&amp;b);</div><div class="line">            merge(a,b);</div><div class="line">        &#125;</div><div class="line">        if(op[1] ==&apos;1&apos;)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot; %d%d&quot;,&amp;a,&amp;b);</div><div class="line">            if(findroot(a)==findroot(b)) puts(&quot;Yes&quot;);</div><div class="line">            else puts(&quot;No&quot;);</div><div class="line">        &#125;</div><div class="line">        if(op[1] == &apos;2&apos;)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot; %d&quot;,&amp;a);</div><div class="line">            printf(&quot;%d\n&quot;,Size[findroot(a)]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><p>带权并查集是结点存有权值信息的并查集。权值代表着当前节点与父节点的某种关系,通过两者关系,也可以将同一棵树下两个节点的关系表示出来。而一般并查集只能判断属于某个集合。</p>
<h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a><font size="5">食物链</font></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h3><p>动物王国中有三类动物A,B,C,这三类动物的食物链构成了有趣的环形。A吃B,B吃C,C吃A。现有N个动物,以1－N编号。每个动物都是A,B,C中的一种,但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述:<br>第一种说法是”1 X Y”,表示X和Y是同类。<br>第二种说法是”2 X Y”,表示X吃Y。<br>此人对N个动物,用上述两种说法,一句接一句地说出K句话,这K句话有的是真的,有的是假的。当一句话满足下列三条之一时,这句话就是假话,否则就是真话。<br>1)当前的话与前面的某些真的话冲突,就是假话;<br>2)当前的话中X或Y比N大,就是假话;<br>3)当前的话表示X吃X,就是假话。<br>你的任务是根据给定的N和K句话,输出假话的总数。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h3><p>第一行是两个整数N和K,以一个空格分隔。<br>以下K行每行是三个正整数 D, X, Y,两数之间用一个空格隔开,其中D表示说法的种类。<br>若D=1,则表示X和Y是同类。<br>若D=2,则表示X吃Y。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h3><p>只有一个整数，表示假话的数目。</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">100 7</div><div class="line">1 101 1 </div><div class="line">2 1 2</div><div class="line">2 2 3 </div><div class="line">2 3 3 </div><div class="line">1 1 3 </div><div class="line">2 3 1 </div><div class="line">1 5 5</div></pre></td></tr></table></figure>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">3</div></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h3><font size="4" color="red">带权并查集</font>:3号吃2号,2号吃1号,1号吃3号,形成一个环。定义两个数组 fa[ ] 和 dis[ ], fa 用来判断集合关系,dis用来描述其与根节点的关系。因为关系满足传递性,所以可以推导出给出条件下的当前关系,在判断与之前已有关系是否矛盾。题目说:若 D=1,则表示X和Y是同类。<font size="4" color="Green">x吃y或者 y 吃 x不成立</font>,<font size="4" color="red">即 x 的捕食域与 y 的同类域在一起</font>;<font size="4" color="red">y 的捕食域与 x 的同类域在一起</font>。若D=2,则表示X吃Y。<font size="4" color="Green">x 和 y 是同类 或者 y 吃 x</font>;<font size="4" color="red">y 的捕食域与 x 的同类域在一起</font>;<font size="4" color="red">x的同类域与y的同类域在一起</font>。对于处理所有点与点之间的关系可以取模处理,<font size="4" color="red">让余数为0表示同类</font>;<font size="4" color="red">余数是1表示吃其同类</font>;<font size="4" color="red">余数是2表示其捕食域</font>。此时和题目叙述略有不同,因此传参时需要让 D 先减 1处理。<br><font size="4" color="red"></font>

<p><img src="http://edviv.gitee.io/images_bed/images/ACM/swl.png" alt=""></p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=5e4+7;</div><div class="line">int fa[maxn],dis[maxn];</div><div class="line">int n,k,ans;</div><div class="line">int d,a,b;</div><div class="line">void Init()   //初始化</div><div class="line">&#123;</div><div class="line">    for(int i=1;i&lt;=n;++i) fa[i]=i,dis[i]=0;</div><div class="line">    ans=0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int findroot(int x)    //查询 + 路径压缩</div><div class="line">&#123;</div><div class="line">    if(x==fa[x]) return x;   // x 是根节点 返回父节点;x 不是根节点  让父节点等于祖宗结点</div><div class="line">    int t=findroot(fa[x]);</div><div class="line">    dis[x]=(dis[x]+dis[fa[x]]+3)%3;</div><div class="line">    fa[x]=t;</div><div class="line">    return fa[x];</div><div class="line">&#125;</div><div class="line">//0类 是同类,即根，1类吃0类，2类被0类吃</div><div class="line">void merge(int r,int x,int y)</div><div class="line">&#123;</div><div class="line">    int tx=findroot(x),ty=findroot(y);</div><div class="line">    if(tx!=ty)</div><div class="line">    &#123;</div><div class="line">        fa[tx]=ty;  //x根并入y根集合</div><div class="line">        //更新x根到新根节点关系</div><div class="line">		//x根到新根节点关系=根到x的关系(~dis[x])+x与y关系(r)+y到根关系</div><div class="line">        dis[tx]=(dis[y]-dis[x]+r+3)%3;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">bool judge(int r,int x,int y)</div><div class="line">&#123;</div><div class="line">    if(x&gt;n||y&gt;n || (r==1 &amp;&amp; x==y)) return false;</div><div class="line">    if(findroot(x)==findroot(y)) //判断x与y关系(r)等于x到根关系+根到y关系(~dis[y])</div><div class="line">        return r == (dis[x]-dis[y]+3)%3;</div><div class="line">    return true;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123; </div><div class="line">    scanf(&quot; %d%d&quot;,&amp;n,&amp;k);</div><div class="line">    Init();</div><div class="line">    while(k--)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot; %d%d%d&quot;,&amp;d,&amp;a,&amp;b);</div><div class="line">        d--;</div><div class="line">        if(judge(d,a,b)) merge(d,a,b);</div><div class="line">        else ans++;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h1><p>一般并查集可以判断一种关系,即属于这种关系或不属于这种关系。比如朋友的朋友是朋友。但比如敌人的敌人是朋友这种涉及两种以上的关系就会用到种类并查集,其实就是用多个并查集来模拟种类。但是如果关系(种类)过多,那么种类并查集写起来很繁琐,带权并查集更占优势。种类并查集还需要足够的空间,对空间限制小的题是硬伤。但是种类并查集更容易理解和模拟,带权并查集需要充分理解其向量思维。</p>
<font size="4" color="red"></font>




<font size="5"></font>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线性Dp</title>
    <url>/2020/06/29/%E7%BA%BF%E6%80%A7Dp/</url>
    <content><![CDATA[<h1 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h1><p><a href="https://vjudge.net/problem/POJ-1163" target="_blank" rel="external">题目链接</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br>        7<br>      3   8<br>    8   1   0<br>  2   7   4   4<br>4   5   2   6   5<br><a id="more"></a></p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>第一行包含整数n，表示数字三角形的层数。<br>接下来n行，每行包含若干整数，其中第 i<br>行表示数字三角形第 i 层包含的整数。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出一个整数，表示最大的路径数字和。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤n≤500,<br>−10000≤三角形中的整数≤10000</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>30</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">dp[i][j]:</font><font size="4" color="Blue">表示从顶层到达第i层第j个位置的最大的得分值</font></p>
<p><font size="4" color="blue">第 i 层第 j 个位置可以由第 i - 1层的第 j 个位置或者第 i - 1 层的第 j - 1 个位置走过来</font></p>
<p><font size="4" color="red">状态转移方程:dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+a[i][j])</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=1e3+7;</div><div class="line">ll dp[maxn][maxn];</div><div class="line">int n,a[maxn][maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">        for(int j=1;j&lt;=i;++j)</div><div class="line">            scanf(&quot;%d&quot;,&amp;a[i][j]);</div><div class="line">    </div><div class="line">    for(int i=0;i&lt;=n;++i)</div><div class="line">        for(int j=0;j&lt;=i+1;++j)</div><div class="line">            dp[i][j]=-1e9;</div><div class="line">            </div><div class="line">    dp[1][1]=a[1][1];        </div><div class="line">    for(int i=2;i&lt;=n;++i)</div><div class="line">        for(int j=1;j&lt;=i;++j)</div><div class="line">            dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j];</div><div class="line">    ll ans=0;</div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">            ans=max(ans,dp[n][i]);</div><div class="line">    printf(&quot;%lld\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h1><p><a href="https://vjudge.net/problem/HDU-1257" target="_blank" rel="external">题目链接</a></p>
<h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>第一行包含整数N。<br>第二行包含N个整数，表示完整序列。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出一个整数，表示最大长度。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">dp[i]:</font><font size="4" color="blue">表示以第 i 个数结尾的最长上升子序列的长度</font></p>
<p><font size="4" color="red">状态转移方程: dp[i]=max(0,dp[j]+1)</font></p>
<p><font size="4" color="red">最后答案:max(dp[i]),时间复杂度O(n^2)</font></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int n,dp[maxn],a[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot;%d&quot;,&amp;n))</div><div class="line">    &#123;</div><div class="line">        memset(dp,0,sizeof(dp));</div><div class="line">        for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line">    </div><div class="line">        for(int i=1;i&lt;=n;++i)</div><div class="line">        &#123;</div><div class="line">            dp[i]=1;</div><div class="line">            for(int j=1;j&lt;i;++j)</div><div class="line">            &#123;</div><div class="line">                if(a[j]&lt;a[i]&amp;&amp;dp[i]&lt;dp[j]+1)</div><div class="line">                    dp[i]=dp[j]+1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int ans=0;</div><div class="line">        for(int i=1;i&lt;=n;++i)</div><div class="line">            if(dp[i]&gt;ans) ans=dp[i];</div><div class="line">        printf(&quot;%d\n&quot;,ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="输出LIS的记录方案"><a href="#输出LIS的记录方案" class="headerlink" title="输出LIS的记录方案"></a><font size="5">输出LIS的记录方案</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int n,dp[maxn],a[maxn];</div><div class="line">int g[maxn],t[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        dp[i]=1;</div><div class="line">        for(int j=1;j&lt;i;++j)</div><div class="line">        &#123;</div><div class="line">            if(a[j]&lt;a[i]&amp;&amp;dp[i]&lt;dp[j]+1)</div><div class="line">            &#123;</div><div class="line">                dp[i]=dp[j]+1;</div><div class="line">                g[i]=j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int k=1;</div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">        if(dp[i]&gt;dp[k]) k=i;</div><div class="line">    printf(&quot;%d\n&quot;,dp[k]);</div><div class="line"></div><div class="line">    int L=dp[k];</div><div class="line">    for(int i=0,len=dp[k];i&lt;len;++i) t[i]=a[k],k=g[k];</div><div class="line"></div><div class="line">    for(int i=L-1;i&gt;=0;--i) printf(&quot;%d &quot;,t[i]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分优化"><a href="#二分优化" class="headerlink" title="二分优化"></a><font size="5">二分优化</font></h2><p><font size="4" color="Blue">定义数组 d[]; len用于统计 d[] 内的数据个数; high[]原始序列</font></p>
<p><font size="4" color="Blue">初始化: d[1]=high[1]; len=1</font></p>
<p><font size="4" color="red">操作步骤:</font></p>
<p><font size="4" color="Blue">逐步处理原数组中的数字，如果当前数字比上一个数字大，那么我们就把这个数字接在上一个数字后面，否则我们就把这个数字接在 d[] 数组中第一个大于它的数字后面。二分查找时间复杂度 O(logn) </font></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int n,high[maxn];</div><div class="line">using namespace std;</div><div class="line">int LIS()</div><div class="line">&#123;</div><div class="line">    int len=1;</div><div class="line">    int d[maxn];</div><div class="line">    d[1]=high[1];</div><div class="line">    for(int i=2;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        if(high[i]&gt;d[len]) d[++len]=high[i];</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            int j=lower_bound(d+1,d+len+1,high[i])-d;</div><div class="line">            d[j]=high[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return len;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot; %d&quot;,&amp;n))</div><div class="line">    &#123;</div><div class="line">        for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;high[i]);</div><div class="line">        printf(&quot;%d\n&quot;,LIS());</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分写法"><a href="#二分写法" class="headerlink" title="二分写法"></a><font size="5">二分写法</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int N=0x3f3f3f3f;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int a[maxn],q[maxn];  //q[i] 存储上升子序列结尾的最小的值</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int len=0,n;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line"></div><div class="line">    q[0]=-N;</div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        int l=0,r=len;</div><div class="line">        while(l&lt;r)</div><div class="line">        &#123;</div><div class="line">            int mid=(l+r)&gt;&gt;1;</div><div class="line">            if(q[mid]&lt;a[i]) l=mid+1;</div><div class="line">            else r=mid;</div><div class="line">        &#125;</div><div class="line">        if(q[r]&lt;a[i]) q[++len]=a[i];</div><div class="line">        else q[r]=a[i];</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,len);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int N=0x3f3f3f3f;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int a[maxn],q[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int len=0,n;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line">    </div><div class="line">    q[0]=-N;</div><div class="line">    for(int i=0;i&lt;n;++i)</div><div class="line">    &#123;</div><div class="line">        int l=0,r=len;</div><div class="line">        while(l&lt;r)</div><div class="line">        &#123;</div><div class="line">            int mid=(l+r+1)&gt;&gt;1;</div><div class="line">            if(q[mid]&lt;a[i]) l=mid;</div><div class="line">            else r=mid-1;</div><div class="line">        &#125;</div><div class="line">        len=max(len,r+1);</div><div class="line">        q[r+1]=a[i];</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,len);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p><a href="https://vjudge.net/problem/HDU-1159" target="_blank" rel="external">题目链接</a></p>
<h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>输入多组数据。<br>每行输入两个字符串A,B。<br>字符串均由小写字母构成。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出一个整数，表示最大长度。</p>
<h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤N≤1000</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">dp[i][j]:</font><font size="4" color="blue">表示在第一个序列的前 i 个字母中出现过，且在第二个序列的前 j 个字母中出现过的子序列</font><br><img src="http://edviv.gitee.io/images_bed/images/ACM/8Hthvj1.png" alt=""></p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#define rep(i,a,b) for(auto i=(a);i&lt;=(b);++i)</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int n,m;</div><div class="line">char a[maxn],b[maxn];</div><div class="line">int dp[maxn][maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot; %s %s&quot;,a+1,b+1))</div><div class="line">    &#123;</div><div class="line">        memset(dp,0,sizeof(dp));</div><div class="line">        n=strlen(a+1);</div><div class="line">        m=strlen(b+1);</div><div class="line"></div><div class="line">        rep(i,1,n)</div><div class="line">        &#123;</div><div class="line">            rep(j,1,m)</div><div class="line">            &#123;</div><div class="line">                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</div><div class="line">                if(a[i]==b[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%d\n&quot;,dp[n][m]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>1.给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：<br>2.删除–将字符串A中的某个字符删除。<br>3.插入–在字符串A的某个位置插入某个字符。<br>4.替换–将字符串A中的某个字符替换为另一个字符。<br>现在请你求出，将A变为B至少需要进行多少次操作。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>第一行包含整数n，表示字符串A的长度。<br>第二行包含一个长度为n的字符串A。<br>第三行包含整数m，表示字符串B的长度。<br>第四行包含一个长度为m的字符串B。<br>字符串中均只包含大写字母。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出一个整数，表示最少操作次数。</p>
<h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤n,m≤1000</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>10<br>AGTCTGACGC<br>11<br>AGTAAGTAGGC</p>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>4</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><img src="http://edviv.gitee.io/images_bed/images/ACM/8H0RP02.png" alt=""></p>
<h2 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">char a[maxn],b[maxn];</div><div class="line">int dp[maxn][maxn];</div><div class="line">int n,m;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %d %s&quot;,&amp;n,a+1);</div><div class="line">    scanf(&quot; %d %s&quot;,&amp;m,b+1);</div><div class="line">    </div><div class="line">    for(int i=1;i&lt;=n;++i) dp[i][0]=i;</div><div class="line">    for(int i=1;i&lt;=m;++i) dp[0][i]=i;</div><div class="line">    </div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        for(int j=1;j&lt;=m;++j)</div><div class="line">        &#123;</div><div class="line">            dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);</div><div class="line">            if(a[i]==b[j]) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);</div><div class="line">            else dp[i][j]=min(dp[i-1][j-1]+1,dp[i][j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,dp[n][m]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。<br>对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。<br>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>第一行包含两个整数n和m。<br>接下来n行，每行包含一个字符串，表示给定的字符串。<br>再接下来m行，每行包含一个字符串和一个整数，表示一次询问。<br>字符串中只包含小写字母，且长度均不超过10。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出共m行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p>
<h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤n,m≤1000</p>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>3 2<br>abc<br>acd<br>bcd<br>ab 1<br>acbd 2</p>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>1<br>3</p>
<h2 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">char a[maxn][maxn],b[maxn];</div><div class="line">int dp[maxn][maxn];</div><div class="line">int n,m;</div><div class="line">int check(char s[],char t[])</div><div class="line">&#123;</div><div class="line">    int la=strlen(s+1),lb=strlen(t+1);</div><div class="line">    for(int i=1;i&lt;=lb;++i) dp[0][i]=i;</div><div class="line">    for(int i=1;i&lt;=la;++i) dp[i][0]=i;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=la;++i)</div><div class="line">    &#123;</div><div class="line">        for(int j=1;j&lt;=lb;++j)</div><div class="line">        &#123;</div><div class="line">            dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);</div><div class="line">            if(s[i]==t[j]) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);</div><div class="line">            else dp[i][j]=min(dp[i-1][j-1]+1,dp[i][j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return dp[la][lb];</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %d %d&quot;,&amp;n,&amp;m);</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot; %s&quot;,a[i]+1);</div><div class="line"></div><div class="line">    int op,res=0;</div><div class="line"></div><div class="line">    while(m--)</div><div class="line">    &#123;</div><div class="line">        res=0;</div><div class="line">        scanf(&quot; %s %d&quot;,b+1,&amp;op);</div><div class="line">        for(int j=1;j&lt;=n;++j)</div><div class="line">            if(check(a[j],b)&lt;=op) res++;</div><div class="line">        printf(&quot;%d\n&quot;,res);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>DFS &amp;&amp; BFS</title>
    <url>/2020/06/29/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>搜索就是通过不停的试探去寻找一种解法。基础：暴力搜索法，深搜和广搜三种<br>高级的有IDDFS,DBFS,A<em>,IDA</em>等等，本蒻今天讲DFS &amp;&amp; BFS。</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><a id="more"></a>
<h2 id="算法过程-DFS-状态-A"><a href="#算法过程-DFS-状态-A" class="headerlink" title="算法过程 DFS(状态 A)"></a>算法过程 DFS(状态 A)</h2><h3 id="1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"><a href="#1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。" class="headerlink" title="1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"></a>1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。</h3><h3 id="2-调用DFS-状态A-t-即先走下一层。"><a href="#2-调用DFS-状态A-t-即先走下一层。" class="headerlink" title="2.调用DFS(状态A+t) 即先走下一层。"></a>2.调用DFS(状态A+t) 即先走下一层。</h3><h2 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h2><p><a href="http://codeforces.com/gym/102394/problem/F" target="_blank" rel="external">CCPC2019哈尔滨站</a></p>
<h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a><font size="5">题面描述</font></h3><p> 六个字符串，从每个字符串中取出一个字符，问能否构成”harbin”？如果能构<br> 则输出”Yes”,否则输出”No”。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h3><p>  多组测试，第一个数字 T 代表测试组数<br>  每组测试输入6个字符串<br>  所有字符串长度之和不超过 2e6</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h3><p>  每组测试输出”Yes”或”No”。</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">char s[2002000];</div><div class="line">bool mp[7][7];</div><div class="line">bool a[7];</div><div class="line">bool dfs(int p)</div><div class="line">&#123;</div><div class="line">    if(p == 7) return true;</div><div class="line">    for(int i = 1; i &lt;= 6; ++i)</div><div class="line">    &#123;</div><div class="line">        if(mp[p][i] &amp;&amp; a[i])</div><div class="line">        &#123;</div><div class="line">            a[i] = 0;</div><div class="line">            if(dfs(p + 1)) return true;</div><div class="line">            a[i] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int T;</div><div class="line">    scanf(&quot;%d&quot;,&amp;T);</div><div class="line">    while(T--)</div><div class="line">    &#123;</div><div class="line">        memset(mp,0,sizeof(mp));</div><div class="line">        memset(a,1,sizeof(a));</div><div class="line">        for(int i = 1; i &lt;= 6; ++i)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%s&quot;,s);</div><div class="line">            int len = strlen(s);</div><div class="line">            for(int j = 0; j &lt; len; ++j)</div><div class="line">                if(s[j] == &apos;h&apos;) mp[i][1] = 1;</div><div class="line">                else if(s[j] == &apos;a&apos;) mp[i][2] = 1;</div><div class="line">                else if(s[j] == &apos;r&apos;) mp[i][3] = 1;</div><div class="line">                else if(s[j] == &apos;b&apos;) mp[i][4] = 1;</div><div class="line">                else if(s[j] == &apos;i&apos;) mp[i][5] = 1;</div><div class="line">                else if(s[j] == &apos;n&apos;) mp[i][6] = 1;</div><div class="line">        &#125;</div><div class="line">        if(dfs(1)) printf(&quot;Yes\n&quot;);</div><div class="line">        else printf(&quot;No\n&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h2><h3 id="题面描述-简单版本"><a href="#题面描述-简单版本" class="headerlink" title="题面描述(简单版本)"></a><font size="5">题面描述(简单版本)</font></h3><p> 有一个 n行m列 的网格，每个格子里非 0 即 1，有 q 次操作，每次<br> 给定一个以(x1,y1)为左上角，(x2,y2)为右下角的矩形内所有格子里<br> 的数字都变成1。问每次操作之后，所有数字为 1 的格子构成的四连通<br> 块的个数。</p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h3><p>输入第一行两个整数 n,m(1 &lt;= n,m &lt;= 300),表示网格的大小。<br>接下来 n 行，每行一个长为 m 的 01串，表示初始网格大小。<br>接下来一行一个整数 q, 表示操作个数。<br>接下来 q 行，每行四个整数 x1, y1, x2, y2(1&lt;=x1&lt;=x2&lt;=n,1&lt;=y1&lt;=y2&lt;=m)<br>表示把以(x1,y1)为左上角，(x2,y2)为右下角的矩形中的元素都变为1。</p>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h3><p>输出共 q 行，每行一个整数，表示每次操作后含有数字1的格子构成的四连通块个数</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h3><p>5 6<br>101010<br>000001<br>101010<br>000001<br>101010<br>3<br>1 2 5 2<br>4 4 4 4<br>1 3 3 6</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a><font size="5">样例输出</font></h3><p>6<br>7<br>2<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 350;</div><div class="line">char mp[maxn][maxn],flag[maxn][maxn];</div><div class="line">int head[4][2]=&#123;&#123;0,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;</div><div class="line">int n, m ,q, ans;</div><div class="line"></div><div class="line">bool inbound(int x, int y)</div><div class="line">&#123;</div><div class="line">    if(x&gt;=1 &amp;&amp; x &lt;= n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m)</div><div class="line">        return true;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dfs(int x,int y)</div><div class="line">&#123;</div><div class="line">    mp[x][y] = &apos;0&apos;;</div><div class="line">    for(int i = 0; i &lt; 4; i++)</div><div class="line">    &#123;</div><div class="line">        int dx = x + head[i][0];</div><div class="line">        int dy = y + head[i][1];</div><div class="line">        if(mp[dx][dy]==&apos;1&apos; &amp;&amp; inbound(dx,dy))</div><div class="line">        &#123;</div><div class="line">            mp[dx][dy] = &apos;0&apos;;</div><div class="line">            dfs(dx,dy);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	cin&gt;&gt;n&gt;&gt;m;</div><div class="line">	for(int i = 1; i &lt;= n; i++)</div><div class="line">	    for(int j = 1; j &lt;= m; j++)</div><div class="line">	        cin&gt;&gt;mp[i][j];</div><div class="line">	cin&gt;&gt;q;</div><div class="line">	while(q--)</div><div class="line">	&#123;</div><div class="line">	    ans = 0;</div><div class="line">		int x1, y1, x2, y2;</div><div class="line">		cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</div><div class="line">		for(int i = x1; i &lt;= x2; i++)</div><div class="line">            for(int j = y1; j &lt;= y2; j++)</div><div class="line">                mp[i][j] = &apos;1&apos;;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                flag[i][j]=mp[i][j];</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">	        for(int j = 1; j &lt;= m; j++)</div><div class="line">	        &#123;</div><div class="line">	            if(mp[i][j] == &apos;1&apos;)</div><div class="line">                &#123;</div><div class="line">                    ans++;</div><div class="line">                    dfs(i,j);</div><div class="line">                &#125;</div><div class="line">	        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                mp[i][j]=flag[i][j];</div><div class="line">        printf(&quot;%d\n&quot;,ans);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="算法过程-广度优先搜索"><a href="#算法过程-广度优先搜索" class="headerlink" title="算法过程(广度优先搜索)"></a>算法过程(广度优先搜索)</h2><h3 id="1-一层一层的走"><a href="#1-一层一层的走" class="headerlink" title="1.一层一层的走"></a>1.一层一层的走</h3><h3 id="2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来"><a href="#2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来" class="headerlink" title="2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来"></a>2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来</h3><h3 id="3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"><a href="#3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并" class="headerlink" title="3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"></a>3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并</h3><p>且以这个状态为”根节点”进行广度优先搜索。</p>
<h3 id="4-直到整个队列为空。"><a href="#4-直到整个队列为空。" class="headerlink" title="4.直到整个队列为空。"></a>4.直到整个队列为空。</h3><h2 id="习题三-走迷宫-Bfs"><a href="#习题三-走迷宫-Bfs" class="headerlink" title="习题三 走迷宫(Bfs)"></a>习题三 走迷宫(Bfs)</h2><h3 id="题面描述-1"><a href="#题面描述-1" class="headerlink" title="题面描述"></a><font size="5">题面描述</font></h3><p> 一个 n行 m 列的迷宫，迷宫的格子里分别放 0 和 1，1 表示可以通过，0表<br> 示不可以通过。<br> 从某个点开始，有四个方向可以走，前进方格中的数字为 1 时表示可以通过，<br> 0表示不可通过，要另找路径。<br> 起点是左上角，输入终点坐标，给出最短路径。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a><font size="5">输入</font></h3><p>6 5 6 5<br>1 0 0 0 0<br>1 1 1 1 1<br>0 0 0 0 1<br>1 1 1 1 1<br>1 0 0 0 0<br>1 1 1 1 1</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a><font size="5">输出</font></h3><p>17<br>(11)(21)-&gt;(22)-&gt;(23)-&gt;(24)-&gt;(25)-&gt;(35)-&gt;(45)-&gt;(44)-&gt;(43)-&gt;(42)-&gt;(41)-&gt;(51)-&gt;(61)-&gt;(62)-&gt;(63)-&gt;(64)-&gt;(65)-&gt;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n,m,tx,ty;</div><div class="line">int mp[110][110];</div><div class="line">int qu[10010];  //模拟队列，存所有的点</div><div class="line">int l,r;    //[l,r)</div><div class="line">int dis[110][110];  //dis[][]表示这个点是否被访问过</div><div class="line">int pre[10010];  //pre[]记录方案</div><div class="line">int dir[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</div><div class="line">bool inbound(int x, int l, int r)</div><div class="line">&#123;</div><div class="line">    if(x &lt; l || x &gt;= r)</div><div class="line">        return false;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void write(int s,int x)</div><div class="line">&#123;</div><div class="line">    if(s == x)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;(%d%d)&quot;,s/m+1,s%m+1);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    write(s,pre[x]);</div><div class="line">    printf(&quot;(%d%d)-&gt;&quot;,x/m+1,x%m+1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void bfs(int s, int t)</div><div class="line">&#123;</div><div class="line">    memset(dis,-1,sizeof(dis));</div><div class="line">    memset(qu,0,sizeof(qu));</div><div class="line">    l = 0; r = 0;</div><div class="line">    qu[0] = s;  //起点存入队列</div><div class="line">    r++;   //保证区间左闭右开</div><div class="line">    dis[s/m][s%m] = 0;</div><div class="line">    while(l &lt; r)</div><div class="line">    &#123;</div><div class="line">        int point = qu[l];  //取出队首元素</div><div class="line">        if(point == t) break;   //到达终点，提前退出</div><div class="line">        l++;  //出队</div><div class="line">        int x = point/m, y = point%m;  //点的位置</div><div class="line">        for(int i = 0; i &lt; 4; i++)   //四个方向扩展</div><div class="line">        &#123;</div><div class="line">            int tx = x + dir[i][0];</div><div class="line">            int ty = y + dir[i][1];</div><div class="line">            if(!inbound(tx,0,n)||!inbound(ty,0,m))</div><div class="line">                continue;</div><div class="line">            if(dis[tx][ty] == -1 &amp;&amp; mp[tx][ty] == 1)</div><div class="line">            &#123;</div><div class="line">                dis[tx][ty] = dis[x][y] + 1;  //(x,y)--&gt;(tx,ty)</div><div class="line">                pre[tx*m+ty] = point; //记录前驱</div><div class="line">                qu[r] = tx*m+ty;  //放入队列</div><div class="line">                r++;   //进队</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,dis[t/m][t%m]);</div><div class="line">    write(s,t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d%d&quot;, &amp;n,&amp;m);</div><div class="line">    scanf(&quot; %d%d&quot;, &amp;tx,&amp;ty);</div><div class="line">    for(int i = 0; i &lt; n; i++)</div><div class="line">        for(int j = 0; j &lt; m; j++)</div><div class="line">            scanf(&quot; %d&quot;, &amp;mp[i][j]);</div><div class="line">    tx--;ty--;</div><div class="line">    bfs(0 ,tx*m+ty);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>搜索解决问题：</em><br>在一个空间中寻找目标<br>空间指的是解空间<br>目标是指目标状态<br>解空间：如果把一个问题的抽象成一个数学上的向量，那么包含这个向量<br>空间，也就是解空间。<br>状态：用于描述问题或问题解的一些向量。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/06/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16693" target="_blank" rel="external">题目链接</a></p>
<h1 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>有一个箱子的容量是 v (0&lt;=v&lt;=20000),同时有 n 个物品(0&lt; n &lt;=30),每个物品有个体积。要求 n 个物品中，任意取若干个装入箱内，使箱子的剩余空间为最小。</em><br><a id="more"></a></p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h2><p><em>一个整数 v，表示箱子容量，一个整数 n 表示有 n 个物品，接下来 n 个整数，分别表示这 n 个物品各自的体积。</em></p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h2><p><em>一个整数，表示箱子的剩余空间。</em></p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h2><p><em>24 6</em><br><em>8 3 12 7 9 7</em></p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p><em>0</em></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">1.确定状态:dp[i][j]表示容量为i，体积为v的背包能够装的最大体积。</font></p>
<p><font size="4" color="red">2.状态转移:<br>(1)不放当前物品 dp[i][j]=dp[i-1][j]<br>(2)放当前物品 dp[i][j]=dp[i-1][j-v[i]]+v[i]<br>dp[i][j]=max{dp[i-1][j-v[i]]+v[i]}</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int v,n,value[40],dp[40][20010];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    cin&gt;&gt;v&gt;&gt;n;</div><div class="line">    for(int i=1;i&lt;=n;++i) cin&gt;&gt;value[i];</div><div class="line">   </div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">        for(int j=v;j&gt;=0;j--)</div><div class="line">            if(j&gt;=value[i])</div><div class="line">                dp[i][j]=max(dp[i-1][j],dp[i-1][j-value[i]]+value[i]);</div><div class="line">            else dp[i][j]=dp[i-1][j];</div><div class="line">      </div><div class="line">    cout&lt;&lt;v-dp[n][v]&lt;&lt;&apos;\n&apos;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Dp-一维数组"><a href="#Dp-一维数组" class="headerlink" title="Dp+一维数组"></a><font size="5">Dp+一维数组</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int v,n,value[40],dp[20010];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    cin&gt;&gt;v&gt;&gt;n;</div><div class="line">    for(int i=1;i&lt;=n;++i) cin&gt;&gt;value[i];</div><div class="line">  </div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        for(int j=v;j&gt;=value[i];--j)</div><div class="line">            dp[j]=max(dp[j],dp[j-value[i]]+value[i]);</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;v-dp[v]&lt;&lt;&apos;\n&apos;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v[i]，价值是 w[i]。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大,输出最大价值。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="5" color="red">1.确定状态:dp[i][j]表示前i个物品恰放入一个容量为j的背包可获得的最大价值。</font></p>
<p><font size="5" color="red">2.状态转移:<br>(1)不放当前物品 dp[i][j]=dp[i-1][j];<br>(2)放当前物品   dp[i][j]=dp[i-1][j-v[i]]+w[i];<br>               dp[i][j]=max{dp[i-1][j-v[i]]+w[i]}</font></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 1e3 + 7;</div><div class="line">int w[maxn],value[maxn];</div><div class="line">int n,v;</div><div class="line">int dp[maxn][maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;v))</div><div class="line">    &#123;</div><div class="line">        memset(dp,0,sizeof(dp));</div><div class="line">        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;value[i]);</div><div class="line">        </div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            for(int j = v; j &gt;= 0; j--)</div><div class="line">            &#123;</div><div class="line">                if(j &gt;= w[i])</div><div class="line">                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + value[i]);</div><div class="line">                else</div><div class="line">                     dp[i][j] = dp[i-1][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%d\n&quot;,dp[n][v]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="就地滚动"><a href="#就地滚动" class="headerlink" title="就地滚动"></a>就地滚动</h2><p><img src="http://edviv.gitee.io/images_bed/images/ACM/3bcuss.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(int i=1;i&lt;=n;++i)</div><div class="line">    for(int j=m;j&gt;=w[i];--j)</div><div class="line">        if(f[j-w[i]]+value[i]&gt;f[j])</div><div class="line">            f[j]=f[j-w[i]]+value[i];</div></pre></td></tr></table></figure></p>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>在01背包的基础上每种物品可以无限使用。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">1.确定状态: dp[i][j]依旧表示前 i 个物品恰放入容量为 j 的背包的最大权值。</font></p>
<p><font size="4" color="red">2.确定状态转移方式:dp[i][j]=max(dp[i-1][j-k<em>v[i]]+k</em>w[i])(0&lt;=k*v[i]&lt;=j)</font></p>
<p><font size="4" color="green">如果采取暴力做法，时间复杂度O(n^3)，数据超过1e3肯定T，然后我们可以采用动态规划中就地滚动的方式</font><br><img src="http://edviv.gitee.io/images_bed/images/ACM/3boIDU.jpg" alt=""></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int n,V;</div><div class="line">int dp[maxn],v[maxn],w[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;V);</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot;%d %d&quot;,&amp;v[i],&amp;w[i]);</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">       for(int j=v[i];j&lt;=V;++j)</div><div class="line">            if(dp[j-v[i]]+w[i]&gt;dp[j])</div><div class="line">                dp[j]=dp[j-v[i]]+w[i];</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,dp[V]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>有 N 件物品和一个容量为 v 的背包，第 i 种物品最多有 n[i] 件，每件费用是 c[i],价值是 w[i]。求解如何装可以在不超过背包的体积情况下价值总和最大。</em></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">朴素做法</font></p>
<p><font size="4" color="blue">状态转移方程和完全背包一样。<br>dp[i][v]=max{dp[i-1][v-kc[i]]+kw<a href="0&lt;=k&lt;=n[i]">i</a>}<br>复杂度O(V(n[1]+n[2]+…+n[i]))</font></p>
<h2 id="朴素做法代码"><a href="#朴素做法代码" class="headerlink" title="朴素做法代码"></a><font size="4">朴素做法代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int n,V;</div><div class="line">int v[maxn],w[maxn],num[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;V);</div><div class="line">    int dp[maxn];</div><div class="line">    memset(dp,0xcf,sizeof(dp));    // -INF</div><div class="line">    dp[0]=0;</div><div class="line">    for(int i=1;i&lt;=n;++i) scanf(&quot;%d %d %d&quot;,&amp;v[i],&amp;w[i],&amp;num[i]);</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=n;++i)</div><div class="line">        for(int j=1;j&lt;=num[i];++j)</div><div class="line">            for(int k=V;k&gt;=v[i];k--)</div><div class="line">                if(dp[k-v[i]]+w[i]&gt;dp[k])</div><div class="line">                    dp[k]=dp[k-v[i]]+w[i];</div><div class="line">                   </div><div class="line">    int ans=0;</div><div class="line">    for(int j=0;j&lt;=V;++j)</div><div class="line">        ans=max(ans,dp[j]);</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a><font size="5">二进制拆分法</font></h2><p><font size="4" color="blue">考虑将第 i 种物品换成若干件物品，使得原问题的第 i<br>种物品可取的每种策略–取0…n[i]件均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。<br>将i件物品分成若干件物品，其中每件物品有一个系数。让这些系数分别为1，2，4，…，2^(k-1),n[<br>i]-2^k+1,且k是满足n[i]-2^k+1&gt;0的最大整数。例如n[i]=13，可以拆分为1，2，4，6的四件物品。</font></p>
<p><font size="4" color="green">将n[i]拆成1，2，4, … ,2^(k-1),N[i]-2^k+1,{k满足n[i]-2^k+1&gt;0}<br></font></p>
<p><font size="4" color="red">(1)1+2+4+…+2^(k-1)+n[i]-2^k+1=n[i],保证了最多有n[i]个物品。</font></p>
<p><font size="4" color="red">(2)1,2,4, … ,2^(k-1),可以凑出1到2^k-1的所有整数,<br>联系二进制的拆分可以证明</font></p>
<p><font size="4" color="red">(3)2^k…n[i]的所有整数可以用若干个上述元素凑出。(可理解成凑n[i]-t,而n[i]<br>是上面所有数的和，t则是一个小于2^k的数，那么所有的数中去掉组成2^k的那些数剩下的就可以组成n[i]-t)</font></p>
<h2 id="二进制拆分代码"><a href="#二进制拆分代码" class="headerlink" title="二进制拆分代码"></a><font size="5">二进制拆分代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int N,V;</div><div class="line">int v[maxn],w[maxn],num[maxn];</div><div class="line">int dp[maxn],vv[maxn],ww[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;N,&amp;V);</div><div class="line">    memset(dp,0xcf,sizeof(dp));  //-INF</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=N;++i) scanf(&quot;%d %d %d&quot;,&amp;v[i],&amp;w[i],&amp;num[i]);</div><div class="line"></div><div class="line">    int total=0;</div><div class="line">    </div><div class="line">    for(int i=1;i&lt;=N;++i)</div><div class="line">    &#123;</div><div class="line">        for(int j=1;j&lt;num[i];j&lt;&lt;=1)//二进制拆分</div><div class="line">         &#123;</div><div class="line">            vv[++total]=j*v[i];//存容量</div><div class="line">            ww[total]=j*w[i];//存价值</div><div class="line">            num[i]-=j;</div><div class="line">         &#125;</div><div class="line">         if(num[i])//当num[i]&gt;0;</div><div class="line">         &#123;</div><div class="line">             vv[++total]=num[i]*v[i];</div><div class="line">             ww[total]=num[i]*w[i];</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dp[0]=0;</div><div class="line">    for(int i=1;i&lt;total;++i)//01背包</div><div class="line">        for(int j=V;j&gt;=vv[i];--j)</div><div class="line">            if(dp[j-vv[i]]+ww[i]&gt;dp[j]) dp[j]=dp[j-vv[i]]+ww[i];</div><div class="line"></div><div class="line">    int ans=0;</div><div class="line">    for(int i=0;i&lt;=V;++i)</div><div class="line">        if(dp[i]&gt;ans) ans=dp[i];</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a><font size="5">二维费用的背包问题</font></h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><font size="4" color="blue">对于每件物品，具有两种不同的费用，选择这种物品必须付出这两种代价，对于每种代价都有一个可付出的最大值(背包容量)。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别是a[i],b[i]。这两种代价可付出的最大值(两种背包容量)分别为 V 和 U。物品的价值为 w[i]。</font></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a><font>解题思路</font></h2><p><font size="4" color="Blue">设dp[i][v][u]表示前i件物品付出两种代价分别为 v 和 u时，可获得的最大价值。</font></p>
<p><font size="4" color="red">状态转移方程: dp[i][v][u]=max{dp[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}</font></p>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a><font size="5">分组背包</font></h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>有N件物品和一个容量为v的背包。第i件物品的费用是c[i],价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选择一件，问:将哪些物品装入背包可使这些物品的费用总和不超过背包容量且价值总和最大。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font color="red" size="4">1.确定状态: dp[k][v]表示前k组物品花费费用v能取得最大值。</font></p>
<p><font color="red" size="4">2.确定状态转移方程:dp[k][v]=max{dp[k-1][v],dp[k-1][v-c[i]]+w[i]|物品i属于组k}</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(所有的组k)</div><div class="line">    for(v--&gt;0)</div><div class="line">        for(所有的i属于组k)</div><div class="line">            dp[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e3+7;</div><div class="line">int N,V;</div><div class="line">int v[maxn][maxn],w[maxn][maxn],num[maxn];</div><div class="line">int dp[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;N,&amp;V);</div><div class="line">    memset(dp,0xcf,sizeof(dp));  //-INF</div><div class="line"></div><div class="line">    for(int i=1;i&lt;=N;++i)</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%d&quot;,&amp;num[i]);</div><div class="line">        for(int j=1;j&lt;=num[i];++j)</div><div class="line">            scanf(&quot;%d %d&quot;,&amp;v[i][j],&amp;w[i][j]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dp[0]=0;</div><div class="line">    for(int i=1;i&lt;=N;++i)//01背包</div><div class="line">        for(int j=V;j&gt;=0;--j)</div><div class="line">            for(int k=1;k&lt;=num[i];++k)</div><div class="line">                if(j&gt;=v[i][k]&amp;&amp;dp[j-v[i][k]]+w[i][k]&gt;dp[j]) dp[j]=dp[j-v[i][k]]+w[i][k];</div><div class="line"></div><div class="line">    int ans=0;</div><div class="line">    for(int i=0;i&lt;=V;++i)</div><div class="line">        if(dp[i]&gt;ans) ans=dp[i];</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>滑雪</title>
    <url>/2020/06/29/%E6%BB%91%E9%9B%AA/</url>
    <content><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h1><p><a href="https://vjudge.net/problem/POJ-1088" target="_blank" rel="external">滑雪</a><br>Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子<br><a id="more"></a><br> 1  2  3  4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h1><p>输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h1><p>输出最长区域的长度。</p>
<h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><font size="5">样例输入</font></h1><p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p>
<h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a><font size="5">样例输出</font></h1><p>25</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h1><p><font size="4" color="red">记忆化搜索</font></p>
<p><font size="4" color="geen">将算过的每一个f[i][j]记录下来,再一次需要算f[i][j]时不再递归直接用记录下来的结果</font></p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn=307;</div><div class="line">int a[maxn][maxn],f[maxn][maxn];</div><div class="line">int r,c,ans;</div><div class="line">int dp(int x,int y)</div><div class="line">&#123;</div><div class="line">    if(f[x][y]) return f[x][y];  //保证每个子问题只读了一遍</div><div class="line">    f[x][y]=1;</div><div class="line">    if(x&gt;1 &amp;&amp; (a[x-1][y]&lt;a[x][y])) f[x][y]=max(f[x][y],dp(x-1,y)+1); //左</div><div class="line">    if(x&lt;r &amp;&amp; (a[x+1][y]&lt;a[x][y])) f[x][y]=max(f[x][y],dp(x+1,y)+1);  //右</div><div class="line">    if(y&gt;1 &amp;&amp; (a[x][y-1]&lt;a[x][y])) f[x][y]=max(f[x][y],dp(x,y-1)+1);  //上</div><div class="line">    if(y&lt;c &amp;&amp; (a[x][y+1]&lt;a[x][y])) f[x][y]=max(f[x][y],dp(x,y+1)+1);  //下</div><div class="line">    return f[x][y];</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    memset(f,0,sizeof f);</div><div class="line">    scanf(&quot; %d%d&quot;,&amp;r,&amp;c);</div><div class="line">    for(int i=1;i&lt;=r;++i)</div><div class="line">        for(int j=1;j&lt;=c;++j)</div><div class="line">            scanf(&quot; %d&quot;,&amp;a[i][j]);</div><div class="line">    </div><div class="line">    for(int i=1;i&lt;=r;++i)</div><div class="line">        for(int j=1;j&lt;=c;++j)</div><div class="line">            ans=max(ans,dp(i,j));</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a><font size="5">记忆化搜索</font></h1><p><font size="4" color="geen">用数组将已经算过的东西记录下来,在下一次使用时直接用已经算出的值,避免重复运算,去掉重复的搜索树。</font></p>
<p><font size="4" color="red">斐波那契数列 f(n)</font></p>
<p><font size="4" color="geen">f[n]=1 if(n==0 || n==1)</font></p>
<p><font size="4" color="geen">f[n]=f[n-1]+f[n-2] if(n&gt;1)</font></p>
<p><font size="4" color="red">递归版</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int f(int n)</div><div class="line">&#123;</div><div class="line">	if(n==0 || n==1) return 1;</div><div class="line">	else return f(n-1)+f(n-2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">递推版</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a[0]=a[1]=1;</div><div class="line">for(int i=2;i&lt;=n;++i) a[i]=a[i-1]+a[i-2];</div><div class="line">return a[n];</div></pre></td></tr></table></figure></p>
<p><font size="4" color="red">记忆化搜索</font></p>
<p><font size="4" color="red">时间复杂度O(n)</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int cal(int n)</div><div class="line">&#123;</div><div class="line">	if(f[n]) return f[n];</div><div class="line">	return (f[n]=cal(n-1)+cal(n-2))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>记忆化搜索相当于搜索中的剪枝,避免重复计算已经出现过的子树,效率比递推和递归版本快的多。</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
  </entry>
  <entry>
    <title>非递归实现组合型枚举</title>
    <url>/2020/06/29/%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://ac.nowcoder.com/acm/contest/998/H" target="_blank" rel="external">题目链接</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>从1~n这n个整数中随机选出m个，输出所有的选择方案。n&gt;0,0&lt;=m&lt;=n,n+(n-m)&lt;=25</em><br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">递归的机制</font></p>
<p><font size="4" color="blue">采用”堆栈结构”实现函数调用,在汇编语言中，把函数所需的第k个，第k-1个，…,第一个参数依次入栈，然后执行 call 指令。当前语句的下一条语句的地址入栈，然后跳转到 idx 位置的语句。在函数返回时执行 ret 指令，把返回地址出栈，并跳转到该地址继续执行。<br>函数定义中C++局部变量，在每次执行 call 与 ret 指令时，也会在”栈”中相应的保存与复原，而作用范围超过该函数的变量，以及通过 new 与 malloc 函数动态分配的空间则保存在另外一块称为”堆”的结构中。栈指针、返回值、局部的运算会借助CPU的”寄存器完成”</font></p>
<p><font size="4" color="red">1.局部变量在每层递归中占有一份空间，声明过多或递归过深就会栈溢出。</font></p>
<p><font size="4" color="red">2.非局部变量对于各层递归都共享同一份空间，需要及时维护，还原现场，以防止在各层递归之间存储和读取的数据互相影响。</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int N=100010;</div><div class="line">vector&lt;int&gt;v,ans[N];</div><div class="line">int st[N],top=0,idx=0,n,m;</div><div class="line">void call(int x,int ret_addr) //模拟计算机汇编指令call</div><div class="line">&#123;</div><div class="line">    int old_top=top;</div><div class="line">    st[++top]=x;  //参数x</div><div class="line">    st[++top]=ret_addr;   //返回地址标号</div><div class="line">    st[++top]=old_top;  //在栈顶记录以前的top值</div><div class="line">&#125;</div><div class="line">int ret()  //模拟计算机汇编指令ret</div><div class="line">&#123;</div><div class="line">    int ret_addr=st[top-1];</div><div class="line">    top=st[top];  //恢复以前的top值</div><div class="line">    return ret_addr;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</div><div class="line">    int id=0;</div><div class="line">    call(1,0); //call(1)</div><div class="line">    while(top)&#123;</div><div class="line">        int x=st[top-2];  //获取参数</div><div class="line">        switch(idx)&#123;</div><div class="line">            case 0:</div><div class="line">                if(v.size()&gt;m||v.size()+(n-x+1)&lt;m)&#123;</div><div class="line">                    idx=ret();  //return</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if(x==n+1)&#123;</div><div class="line">                    for(int i=0;i&lt;v.size();++i)</div><div class="line">                        ans[id].push_back(v[i]);</div><div class="line">                        id++;</div><div class="line">                        idx=ret();   //return</div><div class="line">                        continue;</div><div class="line">                &#125;</div><div class="line">                call(x+1,1);  //相当于calc(x+1),返回后会从case 1继续</div><div class="line">                idx=0;</div><div class="line">                continue;  //回到while循环开头，相当于开始新的递归</div><div class="line">            case 1:</div><div class="line">                    v.push_back(x); //相当于calc(x+1),返回后会从case 2继续</div><div class="line">                    call(x+1,2);</div><div class="line">                    idx=0;</div><div class="line">                    continue;  //回到while循环开头，相当于开始新的递归</div><div class="line">            case 2:</div><div class="line">                    v.pop_back();</div><div class="line">                    idx=ret();   //相当于calc函数的结尾，执行return</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for(int i=id-1;i&gt;=0;--i)&#123;</div><div class="line">        for(vector&lt;int&gt;::iterator it=ans[i].begin();it!=ans[i].end();++it)&#123;</div><div class="line">            cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</div><div class="line">        &#125;</div><div class="line">        puts(&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/06/29/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/A" target="_blank" rel="external">题目链接</a></p>
<h1 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>从1到n中(n&lt;=16)个整数中随机选取任意多个，输出所有可能的选择方案。</em><br><a id="more"></a></p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a><font size="5">输入描述</font></h2><p><em>输入一个整数n</em></p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a><font size="5">输出描述</font></h2><p><em>每行一种方案。同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。对于没有选任何数的方案，输出空行。本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</em></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a><font size="5">样例</font></h2><p>###<font size="5">输入</font><br><em>3</em></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a><font size="5">输出</font></h2><p><em>3</em><br><em>2</em><br><em>2 3</em><br><em>1</em><br><em>1 3</em><br><em>1 2</em><br><em>1 2 3</em></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n;</div><div class="line">vector&lt;int&gt; v;</div><div class="line">void dfs(int x)</div><div class="line">&#123;</div><div class="line">    if(x==n+1)&#123;</div><div class="line">        for(int i=0;i&lt;v.size();++i)</div><div class="line">            std::cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</div><div class="line">        std::cout&lt;&lt;&apos;\n&apos;;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //不选x的分支</div><div class="line">    dfs(x+1);    //求解子问题</div><div class="line">    //选x的分支</div><div class="line">    v.push_back(x); //记录x已经被选择</div><div class="line">    dfs(x+1);   //求解子问题</div><div class="line">    v.pop_back();   //准备回溯到上一问题之前，还原现场</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);</div><div class="line">    cout.tie(0);</div><div class="line">    std::cin&gt;&gt;n;</div><div class="line">    dfs(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/998/B" target="_blank" rel="external">题目链接</a></p>
<h1 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。n&gt;0,0&lt;=m&lt;=n,n+(n-m)&lt;=25,输入两个整数n和m,从小到大输出选取m个数的排列</em></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font color="blue" size="4">搜索的时候剪枝，如果已经选的数超过了m个或者即使再选上剩余的数也不够m个，此问题无解</font></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n,m,idx;</div><div class="line">vector&lt;int&gt; v,data[1000000];</div><div class="line">void dfs(int x)</div><div class="line">&#123;</div><div class="line">    if(v.size()&gt;m || v.size()+n-x+1&lt;m) return;  //剪枝</div><div class="line">    if(x==n+1)&#123;</div><div class="line">        for(int i=0;i&lt;v.size();++i)</div><div class="line">            data[idx].push_back(v[i]);</div><div class="line">        idx++;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    dfs(x+1);</div><div class="line">    v.push_back(x);</div><div class="line">    dfs(x+1);</div><div class="line">    v.pop_back();</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ios::sync_with_stdio(false);</div><div class="line">    cout.tie(0);</div><div class="line">    std::cin&gt;&gt;n&gt;&gt;m;</div><div class="line">    dfs(1);</div><div class="line">    for(int i=idx-1;i&gt;=0;--i)</div><div class="line">    &#123;</div><div class="line">        for(vector&lt;int&gt;::iterator it=data[i].begin(); it!=data[i].end();++it)</div><div class="line">        &#123;</div><div class="line">            std::cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</div><div class="line">        &#125;</div><div class="line">        std::cout&lt;&lt;&apos;\n&apos;;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/998/C" target="_blank" rel="external">题目链接</a></p>
<h1 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>把1到n(n&lt;10)个整数排成一行后随机打乱顺序，输出所有可能的次序</em></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><em>C++ STL的库函数<font color="red">next_permutation()</font><br><strong>作用:</strong>按照从小到大的顺序输出排列</em></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n;</div><div class="line">int data[20];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    for(int i=1;i&lt;=n;++i) data[i]=i;</div><div class="line">    do&#123;</div><div class="line">        for(int i=1;i&lt;=n;++i)</div><div class="line">            printf(&quot;%d &quot;,data[i]);</div><div class="line">        puts(&quot;&quot;);</div><div class="line">    &#125;while(next_permutation(data+1,data+1+n));</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
  </entry>
  <entry>
    <title>递推</title>
    <url>/2020/06/29/%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/D" target="_blank" rel="external">题目链接</a></p>
<h1 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>在一个5X5的矩阵中，点击任意一个位置，该位置及其上下左右四个相邻的位置中的数字都会变化(0变1，1变0)，问能否在6步以内让01矩阵变成全1矩阵。</em><br><a id="more"></a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="blue">1.每个位置最多点击一次。</font></p>
<p><font size="4" color="blue">2.点击的顺序不会影响最终的结果</font></p>
<p><font size="4" color="blue">3.固定第一行，当第i行的位置是0时，只能点击第i+1行的位置，改变第i行的位置只能通过改变第i+1行的位置来改变第i行的位置</font></p>
<p><font size="4" color="red">第一行枚举可以用位运算的方式枚举</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</div><div class="line">using namespace std;</div><div class="line">char ch;</div><div class="line">int a[10][10],t[10][10];</div><div class="line">bool Check()  //全亮true，否则false</div><div class="line">&#123;</div><div class="line">    rep(i,1,5)</div><div class="line">        rep(j,1,5)</div><div class="line">            if(!t[i][j]) return false;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">void Change(int x,int y)</div><div class="line">&#123;</div><div class="line">    t[x][y]^=1;   //本身</div><div class="line">    t[x-1][y]^=1;  //左</div><div class="line">    t[x][y-1]^=1;  //上</div><div class="line">    t[x+1][y]^=1;  //右</div><div class="line">    t[x][y+1]^=1;  //下</div><div class="line">&#125;</div><div class="line">void work()</div><div class="line">&#123;</div><div class="line">    int ans=0x3f3f3f3f;</div><div class="line">    rep(i,1,1&lt;&lt;5)&#123;  //枚举第一行所有状态，第i位是0不用按</div><div class="line">        int tm=0;</div><div class="line">        rep(j,1,5)</div><div class="line">            rep(k,1,5)</div><div class="line">                t[j][k]=a[j][k];</div><div class="line">        rep(j,1,5)</div><div class="line">            if(i&gt;&gt;(j-1)&amp;1)  //C++里面从第0位开始,或者写成 i&gt;&gt;(j-1)&amp;0==0</div><div class="line">            &#123;</div><div class="line">                Change(1,j);</div><div class="line">                tm++;</div><div class="line">            &#125;</div><div class="line">        rep(j,1,4)  //控制第i+1行</div><div class="line">            rep(k,1,5)</div><div class="line">                if(!t[j][k])</div><div class="line">                &#123;</div><div class="line">                    Change(j+1,k);</div><div class="line">                    tm++;</div><div class="line">                &#125;</div><div class="line">        if(Check()) ans=min(ans,tm);</div><div class="line">    &#125;</div><div class="line">    if(ans&gt;6) puts(&quot;-1&quot;);</div><div class="line">    else printf(&quot;%d\n&quot;,ans);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int t;</div><div class="line">    scanf(&quot;%d&quot;,&amp;t);</div><div class="line">    while(t--)</div><div class="line">    &#123;</div><div class="line">        getchar();</div><div class="line">        rep(i,1,5)&#123;</div><div class="line">            rep(j,1,5)&#123;</div><div class="line">                scanf(&quot;%c&quot;,&amp;ch);</div><div class="line">                a[i][j]=ch-48;</div><div class="line">            &#125;</div><div class="line">            getchar();</div><div class="line">        &#125;</div><div class="line">        work();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://ac.nowcoder.com/acm/contest/998/E" target="_blank" rel="external">题目链接</a></p>
<h1 id="Strange-Towers-of-Hanoi"><a href="#Strange-Towers-of-Hanoi" class="headerlink" title="Strange Towers of Hanoi"></a>Strange Towers of Hanoi</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p><em>解出n个盘子4座塔的汉诺塔问题最少需要多少步？</em><br><!--more--></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="green">关于三座汉诺塔问题的最少步骤，有d[n]=2*d[n-1]+1。就是说把前n-1个盘子从A柱移动到B柱，然后把第n个盘子从A柱移动到C柱，最后把前n-1个盘子从B柱移动到C柱</font></p>
<p><font color="red" size="4">dp[n]=min{[2*dp[i]+d[n-i]}(1&lt;=i&lt;=n)</font></p>
<p><font color="green" size="4">dp[1]=1表示先把第i个盘子在四塔模式下移动到B柱，然后把n-i个盘子在3塔模式下移动到D柱，最后把i个盘子在四塔模式下移动到D柱，考虑所有可能的i取最小值</font></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</div><div class="line">using namespace std;</div><div class="line">int dist[20],dp[20];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    dist[1]=1;</div><div class="line">    rep(i,1,12) dist[i]=dist[i-1]*2+1;</div><div class="line">    memset(dp,0x3f,sizeof dp);</div><div class="line">    dp[1]=1;</div><div class="line">    rep(i,2,12)</div><div class="line">        rep(j,1,i-1)</div><div class="line">            dp[i]=min(dp[i],dist[i-j]+2*dp[j]);</div><div class="line">    rep(i,1,12) printf(&quot;%d\n&quot;,dp[i]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题目</category>
      </categories>
  </entry>
  <entry>
    <title>递归与递推</title>
    <url>/2020/06/01/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p>本博客题目来源于<a href="https://www.acwing.com/" target="_blank" rel="external">Acwing</a>,个人学习总结。<br><a href="https://www.acwing.com/activity/content/problem/content/1545/1/" target="_blank" rel="external">递归实现指数型枚举</a></p>
<h1 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>从 1 ~ n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>输入一个整数n。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>每行输出一种方案。<br>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。<br>对于没有选任何数的方案，输出空行。<br>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1&lt;=n&lt;=15</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>3</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>3<br>2<br>2 3<br>1<br>1 3<br>1 2<br>1 2 3</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="blue">递归搜索解空间,到搜索边界输出,每个数只有两种状态,选或是不选,选就记录一下。</font></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">vector&lt; int&gt;v;</div><div class="line">int n;</div><div class="line">void dfs(int x)</div><div class="line">&#123;</div><div class="line">    if(x==n+1)  // 递归边界</div><div class="line">    &#123;</div><div class="line">        for(int i=0;i &lt; v.size();++i) printf(&quot;%d &quot;,v[i]);</div><div class="line">        puts(&quot;&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //不选</div><div class="line">    dfs(x+1);</div><div class="line">    //选</div><div class="line">    v.push_back(x);</div><div class="line">    dfs(x+1);</div><div class="line">    //还原现场</div><div class="line">    v.pop_back();</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %d&quot;,&amp;n);</div><div class="line">    dfs(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="external">递归实现排列型枚举</a></p>
<h1 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>把 1 ~ n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>一个整数n。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数 一一 比较，字典序较小的排在前面。</p>
<h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤n≤9</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>3</p>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><img src="http://edviv.gitee.io/images_bed/images/LanQiao/YXC/Check/DFS1.png" alt=""></p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int n;</div><div class="line">bool vis[20];</div><div class="line">vector &lt;int&gt; v;</div><div class="line">void dfs(int x)</div><div class="line">&#123;</div><div class="line">    if(x&gt;n) //递归边界</div><div class="line">    &#123;</div><div class="line">        for(int i = 0;i &lt; v.size(); ++i) printf(&quot;%d &quot;,v[i]);</div><div class="line">        puts(&quot;&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //解空间</div><div class="line">    for(int i = 1; i &lt;= n; ++i)</div><div class="line">    &#123;</div><div class="line">        if(vis[i]) continue;  //当前这个数已经选择则不选</div><div class="line">        // 选择 i </div><div class="line">        v.push_back(i);   </div><div class="line">        vis[i]=true;</div><div class="line">        // 递归搜索</div><div class="line">        dfs(x+1);</div><div class="line">        //现场还原</div><div class="line">        v.pop_back();</div><div class="line">        vis[i]=false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    dfs(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/activity/content/problem/content/1549/1/" target="_blank" rel="external">简单斐波那契</a></p>
<h1 id="简单斐波那契"><a href="#简单斐波那契" class="headerlink" title="简单斐波那契"></a>简单斐波那契</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>以下数列0 1 1 2 3 5 8 13 21 …被称为斐波纳契数列。<br>这个数列从第3项开始，每一项都等于前两项之和。<br>输入一个整数N，请你输出这个序列的前N项。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>一个整数N。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>在一行中输出斐波那契数列的前N项，数字之间用空格隔开。</p>
<h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>0&lt;N&lt;46</p>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>5</p>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>0 1 1 2 3</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">f[i] = f[i-1] + f[i-2] (1<i<n)< font=""></i<n)<></font></p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=50;</div><div class="line">int f[50],n;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d&quot;,&amp;n);</div><div class="line">    f[1]=1;</div><div class="line">    if(n&gt;1)</div><div class="line">        for(int i=2;i &lt; n;++i) f[i]=f[i-1]+f[i-2];</div><div class="line">    for(int i=0;i &lt; n;++i) printf(&quot;%d &quot;,f[i]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="external">费解的开关</a></p>
<h1 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。<br>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10111</div><div class="line">01101</div><div class="line">10111</div><div class="line">10000</div><div class="line">11011</div></pre></td></tr></table></figure></p>
<p>在改变了最左上角的灯的状态后将变成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">01111</div><div class="line">11101</div><div class="line">10111</div><div class="line">10000</div><div class="line">11011</div></pre></td></tr></table></figure></p>
<p>再改变它正中间的灯后状态将变成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">01111</div><div class="line">11001</div><div class="line">11001</div><div class="line">10100</div><div class="line">11011</div></pre></td></tr></table></figure></p>
<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。<br>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。<br>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p>
<h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>0&lt; n ≤500</p>
<h2 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>3<br>00111<br>01011<br>10001<br>11010<br>11100</p>
<p>11101<br>11101<br>11110<br>11111<br>11111</p>
<p>01111<br>11111<br>11111<br>11111<br>11111</p>
<h2 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>3<br>2<br>-1</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">1.每一行的灯光只按一次。</font></p>
<p><font size="4" color="red">2.每一行开关的操作,完全被前一行的灯的亮灭状态所决定。</font></p>
<p><font size="5" color="red">按法与灯是否开或者关没有影响</font></p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#define INF 0x3f3f3f3f</div><div class="line">using namespace std;</div><div class="line">const int N=10;</div><div class="line">int a[N][N],b[N][N];</div><div class="line">int dir[6][2]=&#123;-1,0,0,0,1,0,0,1,0,-1&#125;;</div><div class="line">bool inbound(int x,int l,int r) //判断位置是否合法</div><div class="line">&#123;</div><div class="line">    if(x&lt;l || x&gt;r) return false;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">bool check()  //判断灯是否全亮</div><div class="line">&#123;</div><div class="line">    for(int i=1;i&lt;=5;++i)</div><div class="line">        for(int j=1;j&lt;=5;++j)</div><div class="line">            if(!b[i][j]) return false; //1表示亮，0表示关</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">void Change(int x,int y)  //转变函数</div><div class="line">&#123;</div><div class="line">    for(int i=0;i&lt;5;++i)</div><div class="line">    &#123;</div><div class="line">        int tx=x+dir[i][0],ty=y+dir[i][1];</div><div class="line">        if(!inbound(tx,1,5)||!inbound(ty,1,5)) continue;</div><div class="line">        b[tx][ty]^=1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void work()</div><div class="line">&#123;</div><div class="line">    int ans=INF;</div><div class="line">    for(int i=1;i&lt;=1&lt;&lt;5;++i)  //32种状态,二进制状态枚举</div><div class="line">    &#123;</div><div class="line">        memcpy(b,a,sizeof(a));  //复制</div><div class="line">        int step=0;</div><div class="line">        for(int j=1;j&lt;=5;++j)  //枚举第一行</div><div class="line">        &#123;</div><div class="line">            if(!(i&gt;&gt;(j-1)&amp;1))  //第一行的第j个灯是关着的,0按，1不按</div><div class="line">            &#123;</div><div class="line">                Change(1,j);</div><div class="line">                step++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for(int j=1;j&lt;=4;++j)  //剩下i+1行</div><div class="line">            for(int k=1;k&lt;=5;++k)</div><div class="line">                if(!b[j][k])</div><div class="line">                &#123;</div><div class="line">                    step++;</div><div class="line">                    Change(j+1,k);</div><div class="line">                &#125;</div><div class="line">            if(check()) ans=min(ans,step);</div><div class="line">    &#125;</div><div class="line">    if(ans&gt;6) puts(&quot;-1&quot;);</div><div class="line">    else printf(&quot;%d\n&quot;,ans);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int t;</div><div class="line">    scanf(&quot; %d&quot;,&amp;t);</div><div class="line">    while(t--)</div><div class="line">    &#123;</div><div class="line">        getchar();</div><div class="line">        char ch;</div><div class="line">        for(int i=1;i&lt;=5;++i)&#123;</div><div class="line">            for(int j=1;j&lt;=5;++j)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot; %c&quot;,&amp;ch);</div><div class="line">                a[i][j]=ch-&apos;0&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        getchar();</div><div class="line">        work();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/activity/content/problem/content/1547/1/" target="_blank" rel="external">递归实现组合型枚举</a></p>
<h1 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>从 1 ~ n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>两个整数 n，m，在同一行用空格隔开。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。</p>
<h2 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>n&gt;0 ,<br>0≤m≤n ,<br>n+(n−m)≤25</p>
<h2 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>5 3</p>
<h2 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>1 2 3<br>1 2 4<br>1 2 5<br>1 3 4<br>1 3 5<br>1 4 5<br>2 3 4<br>2 3 5<br>2 4 5<br>3 4 5 </p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">递归搜索,剪枝</font></p>
<h2 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e5+7;</div><div class="line">vector&lt;int&gt;v,ans[maxn];</div><div class="line">int n,m,idx;</div><div class="line">void dfs(int x)</div><div class="line">&#123;</div><div class="line">    if(v.size()&gt;m||v.size()+(n-x+1)&lt;m) return; //剪枝</div><div class="line">    if(x==n+1)  //递归边界</div><div class="line">    &#123;</div><div class="line">        for(int i=0;i&lt;v.size();++i) ans[idx].push_back(v[i]);</div><div class="line">        idx++;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    dfs(x+1);</div><div class="line">    v.push_back(x);</div><div class="line">    dfs(x+1);</div><div class="line">    v.pop_back();</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %d%d&quot;,&amp;n,&amp;m);</div><div class="line">    dfs(1);</div><div class="line">    </div><div class="line">    for(int i=idx-1;i&gt;=0;--i)&#123;</div><div class="line">        for(vector&lt;int&gt;::iterator it=ans[i].begin();it!=ans[i].end();++it)&#123;</div><div class="line">            cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</div><div class="line">        &#125;</div><div class="line">        puts(&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=1e5+7;</div><div class="line">int ans[maxn],n,m;</div><div class="line">void dfs(int x,int s)</div><div class="line">&#123;</div><div class="line">    if(x+n-s&lt;m) return; //剪枝</div><div class="line">    if(x==m+1)</div><div class="line">    &#123;</div><div class="line">        for(int i=1;i&lt;=m;++i) printf(&quot;%d &quot;,ans[i]);</div><div class="line">        puts(&quot;&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    for(int i=s;i&lt;=n;++i)</div><div class="line">    &#123;</div><div class="line">        ans[x]=i;</div><div class="line">        dfs(x+1,i+1);</div><div class="line">        // 恢复现场</div><div class="line">        ans[x]=0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</div><div class="line">    dfs(1,1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/activity/content/problem/content/1551/1/" target="_blank" rel="external">带分数</a></p>
<h1 id="带分数"><a href="#带分数" class="headerlink" title="带分数"></a>带分数</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>100 可以表示为带分数的形式：100=3+69258714<br>还可以表示为：100=82+3546197<br>注意特征：带分数中，数字 1 ∼ 9 分别出现且只出现一次（不包含 0）。<br>类似这样的带分数，100 有 11 种表示法。</p>
<h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>一个正整数。</p>
<h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。</p>
<h2 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤N&lt;10^6</p>
<h2 id="输入样例-5"><a href="#输入样例-5" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><p>100</p>
<h2 id="输出样例-5"><a href="#输出样例-5" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>11</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">n = a + b/c –&gt; nc = ac + b</font></p>
<p><font size="4" color="red">枚举 a; 枚举 c; 判断 b 是否成立。</font></p>
<h2 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=15;</div><div class="line">typedef long long ll;</div><div class="line">int n,ans;</div><div class="line">bool vis[maxn],t[maxn];</div><div class="line">bool check(int a,int c)</div><div class="line">&#123;</div><div class="line">    ll b=(ll)(n-a)*c;  //求b</div><div class="line">    if(!a || !b || !c) return false;  //a!=0,b!=0,c!=0</div><div class="line">    memcpy(t,vis,sizeof vis);  //复制</div><div class="line">    while(b)  //枚举b的每一位</div><div class="line">    &#123;</div><div class="line">        ll x=b%10; </div><div class="line">        b/=10;</div><div class="line">        if(!x || t[x]) return false;</div><div class="line">        t[x]=1;</div><div class="line">    &#125;</div><div class="line">    for(int i=1;i&lt;=9;++i)  </div><div class="line">        if(!t[i]) return false;  //有没出现过的数字</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">void dfs_c(int s,int a,int c)</div><div class="line">&#123;</div><div class="line">    if(check(a,c)) ans++;  //满足条件</div><div class="line">    for(int i=1;i&lt;=9;++i)   </div><div class="line">        if(!vis[i])   //未出现过</div><div class="line">        &#123;</div><div class="line">            vis[i]=1;  // 记录</div><div class="line">            dfs_c(s+1,a,c*10+i);  //搜索</div><div class="line">            vis[i]=0;  //回溯</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">void dfs_a(int s,int a) //s:当前状态, a:枚举的数字</div><div class="line">&#123;</div><div class="line">    if(a&gt;=n) return;   //边界</div><div class="line">    if(a) dfs_c(s,a,0);  // a!=0</div><div class="line">    for(int i=1;i&lt;=9;++i)</div><div class="line">        if(!vis[i])   //未出现过</div><div class="line">        &#123;</div><div class="line">            vis[i]=1;  //记录</div><div class="line">            dfs_a(s+1,a*10+i); //搜索</div><div class="line">            vis[i]=0;  //回溯</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %d&quot;,&amp;n);</div><div class="line">    dfs_a(0,0);</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/118/" target="_blank" rel="external">飞行员兄弟</a></p>
<h1 id="飞行员兄弟"><a href="#飞行员兄弟" class="headerlink" title="飞行员兄弟"></a>飞行员兄弟</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有16个把手的冰箱。<br>已知每个把手可以处于以下两种状态之一：打开或关闭。<br>只有当所有把手都打开时，冰箱才会打开。<br>把手可以表示为一个4х4的矩阵，您可以改变任何一个位置[i,j]上把手的状态。<br>但是，这也会使得第i行和第j列上的所有把手的状态也随着改变。<br>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
<h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>输入一共包含四行，每行包含四个把手的初始状态。<br>符号“+”表示把手处于闭合状态，而符号“-”表示把手处于打开状态。<br>至少一个手柄的初始状态是关闭的。</p>
<h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>第一行输出一个整数N，表示所需的最小切换把手次数。<br>接下来N行描述切换顺序，每行输入两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。<br>注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<h2 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>1≤i,j≤4</p>
<h2 id="输入样例-6"><a href="#输入样例-6" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-+--</div><div class="line">----</div><div class="line">----</div><div class="line">-+--</div></pre></td></tr></table></figure>
<h2 id="输出样例-6"><a href="#输出样例-6" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><p>6<br>1 1<br>1 3<br>1 4<br>4 1<br>4 3<br>4 4</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">1.二进制状态枚举,总共有1&lt;<16种情况。< font=""></16种情况。<></font></p>
<p><font size="4" color="red">2.开关的关闭或者打开与其自身的状态没有关系。</font></p>
<h2 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#define f first</div><div class="line">#define s second</div><div class="line">#define pb push_back</div><div class="line">using namespace std;</div><div class="line">typedef pair&lt;int,int&gt;PII;</div><div class="line">const int maxn=10;</div><div class="line">char a[maxn][maxn],t[maxn][maxn];</div><div class="line">void turn(int x,int y)  //转换</div><div class="line">&#123;</div><div class="line">    for(int i=0;i&lt;4;++i)</div><div class="line">    &#123;</div><div class="line">        if(a[x][i]==&apos;-&apos;) a[x][i]=&apos;+&apos;;</div><div class="line">        else a[x][i]=&apos;-&apos;;</div><div class="line">        if(a[i][y]==&apos;-&apos;) a[i][y]=&apos;+&apos;;</div><div class="line">        else a[i][y]=&apos;-&apos;;</div><div class="line">    &#125;</div><div class="line">    if(a[x][y]==&apos;-&apos;) a[x][y]=&apos;+&apos;;</div><div class="line">    else a[x][y]=&apos;-&apos;;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    for(int i=0;i&lt;4;++i) scanf(&quot; %s&quot;,a[i]);</div><div class="line">    vector&lt;PII&gt;ans;</div><div class="line">    for(int op=0;op&lt;(1&lt;&lt;16);++op)</div><div class="line">    &#123;</div><div class="line">        memcpy(t,a,sizeof t);  //备份</div><div class="line">        vector&lt;PII&gt;temp;   //临时变量</div><div class="line">        for(int i=0;i&lt;4;++i)  //操作</div><div class="line">            for(int j=0;j&lt;4;++j)</div><div class="line">                if(op&gt;&gt;(i*4+j)&amp;1)</div><div class="line">                &#123;</div><div class="line">                    temp.pb(&#123;i,j&#125;);</div><div class="line">                    turn(i,j);</div><div class="line">                &#125;</div><div class="line">        bool ok=true;  //判断灯是否全亮的标志</div><div class="line">        for(int i=0;i&lt;4;++i)</div><div class="line">            for(int j=0;j&lt;4;++j)</div><div class="line">                if(a[i][j]==&apos;+&apos;) ok=false;</div><div class="line">        if(ok&amp;&amp;(ans.empty()||ans.size()&gt;temp.size())) ans=temp;</div><div class="line">        memcpy(a,t,sizeof a);</div><div class="line">    &#125;</div><div class="line">    int len=ans.size();</div><div class="line">    printf(&quot;%d\n&quot;,len);</div><div class="line">    for(int i=0;i&lt;len;++i) printf(&quot;%d %d\n&quot;,ans[i].f+1,ans[i].s+1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/activity/content/problem/content/1553/1/" target="_blank" rel="external">翻硬币</a></p>
<h1 id="翻硬币"><a href="#翻硬币" class="headerlink" title="翻硬币"></a>翻硬币</h1><h2 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a><font size="5">题目大意</font></h2><p>小明正在玩一个“翻硬币”的游戏。<br>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。<br>比如，可能情形是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">**oo***oooo</div></pre></td></tr></table></figure></p>
<p>如果同时翻转左边的两个硬币，则变为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">oooo***oooo</div></pre></td></tr></table></figure></p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？<br>我们约定：把翻动相邻的两个硬币叫做一步操作。</p>
<h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a><font size="5">输入格式</font></h2><p>两行等长的字符串，分别表示初始状态和要达到的目标状态。</p>
<h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a><font size="5">输出格式</font></h2><p>一个整数，表示最小操作步数</p>
<h2 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a><font size="5">数据范围</font></h2><p>输入字符串的长度均不超过100。<br>数据保证答案一定有解。</p>
<h2 id="输入样例-7"><a href="#输入样例-7" class="headerlink" title="输入样例"></a><font size="5">输入样例</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">**********</div><div class="line">o****o****</div></pre></td></tr></table></figure>
<h2 id="输出样例-7"><a href="#输出样例-7" class="headerlink" title="输出样例"></a><font size="5">输出样例</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">5</div></pre></td></tr></table></figure>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a><font size="5">解题思路</font></h2><p><font size="4" color="red">贪心思路:枚举对应位置是否相等,不等就改变当前状态和下一个状态,最后输出答案。</font></p>
<p><font size="4" color="red"></font></p>
<h2 id="AC代码-7"><a href="#AC代码-7" class="headerlink" title="AC代码"></a><font size="5">AC代码</font></h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn=107;</div><div class="line">char s[maxn],p[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot; %s %s&quot;,s,p);</div><div class="line">    int ans=0;</div><div class="line">    int lens=strlen(s);</div><div class="line">    for(int i=0,j=0;i&lt;lens;++i,++j)</div><div class="line">           if(s[i]!=p[j])</div><div class="line">           &#123;</div><div class="line">               ans++;</div><div class="line">               if(s[i+1]==&apos;*&apos;) s[i+1]=&apos;o&apos;;</div><div class="line">               else s[i+1]=&apos;*&apos;;</div><div class="line">           &#125;</div><div class="line">    printf(&quot;%d\n&quot;,ans);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo-Theme-Sakura</title>
    <url>/2020/05/27/Hexo-Theme-Sakura/</url>
    <content><![CDATA[<p>hexo-theme-sakura主题 <a href="https://github.com/honjun/hexo-theme-sakura/blob/master/README.md" target="_blank" rel="external">English document</a></p>
<p>基于WordPress主题<a href="https://github.com/mashirozx/Sakura/" target="_blank" rel="external">Sakura</a>修改成Hexo的主题。</p>
<p><a href="https://sakura.hojun.cn" target="_blank" rel="external">demo预览</a></p>
<p>正在开发中……</p>
<p><img src="https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg" alt=""></p>
<h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>若你是使用者，加群QQ: 801511924</p>
<p>若你是创作者，加群QQ: 194472590</p>
<h2 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h2><ul>
<li>首页大屏视频</li>
<li>首页随机封面</li>
<li>图片懒加载</li>
<li>valine评论</li>
<li>fancy-box相册</li>
<li>pjax支持，音乐不间断</li>
<li>aplayer音乐播放器</li>
<li>多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）</li>
</ul>
<h2 id="赞赏作者"><a href="#赞赏作者" class="headerlink" title="赞赏作者"></a>赞赏作者</h2><p>如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！</p>
<p><a href="https://www.paypal.me/hojuncn" target="_blank" rel="external">paypal</a> | <a href="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg" target="_blank" rel="external">Alipay 支付宝</a> | <a href="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg" target="_blank" rel="external">WeChat Pay 微信支付</a></p>
<h2 id="未完善的使用教程"><a href="#未完善的使用教程" class="headerlink" title="未完善的使用教程"></a>未完善的使用教程</h2><p>那啥？老实说我目前也不是很有条理233333333~</p>
<h2 id="1、主题下载安装"><a href="#1、主题下载安装" class="headerlink" title="1、主题下载安装"></a>1、主题下载安装</h2><p><a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" rel="external">hexo-theme-sakura</a>建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。</p>
<p>下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行<code>npm i</code>安装依赖。</p>
<h2 id="2、主题配置"><a href="#2、主题配置" class="headerlink" title="2、主题配置"></a>2、主题配置</h2><h3 id="博客根目录下的-config配置"><a href="#博客根目录下的-config配置" class="headerlink" title="博客根目录下的_config配置"></a>博客根目录下的_config配置</h3><p>站点</p>
<pre>
<code>
# Site
title: 你的站点名
subtitle:
description: 站点简介
keywords:
author: 作者名
language: zh-cn
timezone:
</code>
</pre>

<p>部署</p>
<pre>
  <code>
deploy:
  type: git
  repo: 
    github: 你的github仓库地址
    # coding: 你的coding仓库地址
  branch: master
  </code>
</pre>

<p>备份 （使用hexo b发布备份到远程仓库）</p>
<pre>
  <code>
backup:
  type: git
  message: backup my blog of https://honjun.github.io/
  repository:
    # 你的github仓库地址,备份分支名  （建议新建backup分支）
    github: https://github.com/honjun/honjun.github.io.git,backup
    # coding: https://git.coding.net/hojun/hojun.git,backup
    </code>
</pre>

<h3 id="主题目录下的-config配置"><a href="#主题目录下的-config配置" class="headerlink" title="主题目录下的_config配置"></a>主题目录下的_config配置</h3><p>其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分</p>
<pre>
  <code>
  site name
  #站点名 【改】
  prefixName: さくら荘その
  siteName: hojun
  </code>
</pre>

<pre>
  <code>
    #favicon and site master avatar
    #站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，
    建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】
    favicon: /images/favicon.ico
    avatar: /img/custom/avatar.jpg
  </code>
</pre> 

<pre>
  <code>
    #站点url 【改】
    url: https://sakura.hojun.cn
    #站点介绍（或者说是个人签名）【改】
    description: Live your life with passion! With some drive!
    #站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填
    https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg
    cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6
    </code>
</pre>

<pre>
  <code>
    #开启pjax 【选】
    pjax: 1
    #站点首页的公告信息 【改】
    notice: hexo-Sakura主题已经开源，目前正在开发中...
    #懒加载的加载中图片 【选】
    lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg
  </code>
</pre>

<pre>
  <code>
    #站点菜单配置 【选】
    menus:
    首页: { path: /, fa: fa-fort-awesome faa-shake }
      归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 
      技术: {path: /categories/技术/, fa: fa-code }, 
      生活: {path: /categories/生活/, fa: fa-file-text-o }, 
      资源: {path: /categories/资源/, fa: fa-cloud-download }, 
      随想: {path: /categories/随想/, fa: fa-commenting-o },
      转载: {path: /categories/转载/, fa: fa-book }
      } }
    清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 
      书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 
      番组: {path: /bangumi/, fa: fa-film faa-vertical }, 
      歌单: {path: /music/, fa: fa-headphones },
      图集: {path: /tags/图集/, fa: fa-photo }
    } }
    留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada }
    友人帐: { path: /links/, fa: fa-link faa-shake }
    赞赏: { path: /donate/, fa: fa-heart faa-pulse }
    关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 
      我？: {path: /about/, fa: fa-meetup}, 
      主题: {path: /theme-sakura/, fa: iconfont icon-sakura },
      Lab: {path: /lab/, fa: fa-cogs },
    } }
    客户端: { path: /client/, fa: fa-android faa-vertical }
    RSS: { path: /atom.xml, fa: fa-rss faa-pulse }
  </code>
</pre>

<pre>
  <code>
    Home page sort type: -1: newer first，1: older first. 【非】
    homePageSortType: -1
    Home page article shown number) 【非】
    homeArticleShown: 10
    #背景图片 【选】
    bgn: 8
    startdash面板 url, title, desc img 【改】
    startdash: 
      - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png}
      - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg}
      - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg}
      # your site build time or founded date
      # 你的站点建立日期 【改】
      siteBuildingTime: 07/17/2018
  </code>
</pre>

<pre>
  <code>
    # 社交按钮(social)  url, img PC端配置 【改】
    social:
      github: {url: http://github.com/honjun, img: /img/social/github.png}
      sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png}
      wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png}
      zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png}
      email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg}
      wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png}
    # 社交按钮(msocial)  url, img 移动端配置 【改】
    msocial:
      github: {url: http://github.com/honjun, fa: fa-github, color: 333}
      weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39}
      qq: {url: https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes, fa: fa-qq, color: 25c6fe}
  </code>
</pre>

<pre>
  <code>
    # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】
    donate:
    alipay: /img/custom/donate/AliPayQR.jpg
    wechat: /img/custom/donate/WeChanQR.jpg
    wechatSQ: /img/custom/donate/WeChanSQ.jpg
  </code>
</pre>

<pre>
  <code>
    # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】
    movies:
    url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2
    # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用
    name: Unbroken.mp4
  </code>
</pre>

<pre>
  <code>
# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】
aplayer: 
  id: 2660651585
  server: netease
  type: playlist
  fixed: true
  mini: false
  autoplay: false
  loop: all
  order: random
  preload: auto
  volume: 0.7
  mutex: true
# Valine评论配置【改】
valine: true
v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz
v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ
</code>
</pre>

<h2 id="分类页和标签页配置"><a href="#分类页和标签页配置" class="headerlink" title="分类页和标签页配置"></a>分类页和标签页配置</h2><h3 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h3><p><img src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg" alt=""></p>
<h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p><img src="https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg" alt=""></p>
<p>配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。</p>
<pre>
  <code>
#category
# 按分类名创建
技术:
    #中文标题
    zh: 野生技术协会 
    # 英文标题
    en: Geek – Only for Love
    # 封面图片
    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg
生活:
    zh: 生活
    en: live
    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg

#tag
# 标签名即是标题
悦读:
    # 封面图片
    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg
  </code>
</pre>

<h2 id="单页面封面配置"><a href="#单页面封面配置" class="headerlink" title="单页面封面配置"></a>单页面封面配置</h2><p><img src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg" alt=""><br>如留言板页面页面，位于source下的comment下，打开index.md如下：</p>
<pre>
  <code>
title: comment
date: 2018-12-20 23:13:48
keywords: 留言板
description: 
comments: true
# 在这里配置单页面头部图片，自定义替换哦~
photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg
  </code>
</pre>

<h2 id="单页面配置"><a href="#单页面配置" class="headerlink" title="单页面配置"></a>单页面配置</h2><h3 id="番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"><a href="#番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）" class="headerlink" title="番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"></a>番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src="https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg" alt=""></p>
<pre>
  <code>
layout: bangumi
title: bangumi
comments: false
date: 2019-02-10 21:32:48
keywords:
description:
bangumis:
  # 番组图片
  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg
  # 番组名
    title: 朝花夕誓——于离别之朝束起约定之花
  # 追番状态 （追番ing/已追完）
    status: 已追完
  # 追番进度
    progress: 100
  # 番剧日文名称
    jp: さよならの朝に約束の花をかざろう
  # 放送时间
    time: 放送时间: 2018-02-24 SUN.
  # 番剧介绍
    desc:  住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。
  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg
    title: 朝花夕誓——于离别之朝束起约定之花
    status: 已追完
    progress: 50
    jp: さよならの朝に約束の花をかざろう
    time: 放送时间: 2018-02-24 SUN.
    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。
  </code>
</pre>

<h3 id="友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"><a href="#友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）" class="headerlink" title="友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"></a>友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg" alt=""></p>
<pre>
  <code>
layout: links
title: links
# 创建日期，可以改下
date: 2018-12-19 23:11:06 
# 图片上的标题，自定义修改
keywords: 友人帐 
description: 
# true/false 开启/关闭评论
comments: true 
# 页面头部图片，自定义修改
photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg 
# 友链配置
links: 
  # 类型分组
  - group: 个人项目
    # 类型简介
    desc: 充分说明这家伙是条咸鱼 < (￣︶￣)>
    items:
    # 友链链接
    - url: https://shino.cc/fgvf
    # 友链头像
      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg
    # 友链站点名
      name: Google
    # 友链介绍  下面雷同
      desc: Google 镜像
    - url: https://shino.cc/fgvf
      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg
      name: Google
      desc: Google 镜像
  # 类型分组...
  - group: 小伙伴们
    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)
    items:
    - url: https://shino.cc/fgvf
      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg
      name: Google
      desc: Google 镜像
    - url: https://shino.cc/fgvf
      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg
      name: Google
      desc: Google 镜像
  </code>
</pre>

<h2 id="写文章配置"><a href="#写文章配置" class="headerlink" title="写文章配置"></a>写文章配置</h2><p>主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% bili video_id [page] %&#125;</div></pre></td></tr></table></figure>
<p>详细使用教程详见<a href="https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md" target="_blank" rel="external">hexo-tag-bili</a>。</p>
<p>hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% fb_img src [caption] %&#125;</div></pre></td></tr></table></figure>
<p>详细使用教程详见<a href="https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md" target="_blank" rel="external">hexo-tag-fancybox_img</a></p>
<h2 id="还有啥，一时想不起来……"><a href="#还有啥，一时想不起来……" class="headerlink" title="还有啥，一时想不起来……"></a>还有啥，一时想不起来……</h2><p>To be continued…</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
