<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈Dp与贪心</title>
    <url>/2019/12/05/%E6%B5%85%E8%B0%88Dp%E4%B8%8E%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h1 id="贪心算法和动态规划的关系"><a href="#贪心算法和动态规划的关系" class="headerlink" title="贪心算法和动态规划的关系"></a>贪心算法和动态规划的关系</h1><table>
<thead>
<tr>
<th>技术</th>
<th>贪心算法</th>
<th>动态规划</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用类型</td>
<td>优化问题</td>
<td>通用问题</td>
</tr>
<tr>
<td>特征</td>
<td></td>
<td>动态规划的任何一个i+1阶段都仅仅依赖i阶段做出的选择。而与i之前的选择无关。但是动态规划不仅求出了当前状态的最优值，而且同时求出来到中间状态的最优值</td>
</tr>
<tr>
<td>子问题结构</td>
<td>很多子问题重复（不相互独立）</td>
<td>每个子问题不同（相互独立）</td>
</tr>
<tr>
<td>使用条件</td>
<td>贪心选择+优化原则，多步判断</td>
<td>优化原则，多步判断</td>
</tr>
<tr>
<td>选择依据</td>
<td>局部最优性质</td>
<td>子问题结果</td>
</tr>
<tr>
<td>计算过程</td>
<td>每一步根据策略得到一个当前最优解，传递到下一步，从而保证每一步都选择了当前最优解，最后得到结果以迭代方式做出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题</td>
<td>每一步根据策略得到一个更小规模的问题，最后解决最小规模的问题，得到整个问题最优解</td>
</tr>
<tr>
<td>数据结构</td>
<td>线性表</td>
<td>二维表</td>
</tr>
<tr>
<td>解</td>
<td>不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题都能产生整体最优解或整体最优解的近似解</td>
<td>一个最优解</td>
</tr>
<tr>
<td>关键问题</td>
<td>贪心选择性质证明，近似解的误差估计</td>
<td>递推方程，空间复杂度高</td>
</tr>
<tr>
<td>最优子结构</td>
<td>必须满足</td>
<td>不需要</td>
</tr>
<tr>
<td>子问题数</td>
<td>全部子问题都要解决</td>
<td>全部子问题都要解决</td>
</tr>
<tr>
<td>选择与求解次序</td>
<td>先解决子问题，后选择</td>
<td>先选择，后解决子问题</td>
</tr>
<tr>
<td>依赖</td>
<td>依赖于当前已经做出的所有选择</td>
<td>依赖于有待做出的最优选择</td>
</tr>
</tbody>
</table>
<h2 id="浅谈"><a href="#浅谈" class="headerlink" title="浅谈"></a>浅谈</h2><p>贪心算法和动态规划都是最优解问题，组成最优解的每一个子问题的解对于这个问题本身肯定也是最优的。而大部分的最优解问题都可以转换为解空间问题，将大问题拆分成一个个的子问题，对解空间的遍历视作是对子问题树的遍历。<br>贪心算法和动态规划本质上是对子问题树的一种修剪。Dp是通过自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，将其他的值舍弃。贪心算法是Dp的一个特例，每一个子树的根的值不取决于下面叶子的值，而取决于当前问题的状况。</p>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><blockquote>
<p>走出迷宫的人们，有的是认识路；有的是莽撞碰巧出来的；有的则是一路做着标记出来的；也有的是走遍了整个迷宫。<br>——证明了的贪心算法、没有证明的贪心算法、动态规划、暴力搜索的区别。</p>
</blockquote>
<p>从做题的经历来看，我经常会把贪心的题当成DP来做。事实上，的确所有的贪心问题都可以用DP做出来，反之则不一定成立。DP和贪心都是搜索，但是与暴搜比起来，他们的优点就是进行了剪枝，从而避免了许多无用的搜索。直白一点的解释就是，DP和贪心不用遍历整个解空间，或者说不用重复计算某个子问题。</p>
<p>本质上来说，这两种算法具有最优子结构性质，既均用局部最优解来推导全局最优解 ，一般用递归实现。求全局最优解的问题，从根本上说是一种对解空间的遍历。而直接的暴力穷举很容易造成超时，在大多数情况下是不可行的。但是最优解问题在大部分情况下都可以拆分成一个个的子问题，把解空间的遍历也可以视作对子问题树的遍历，则以某种形式对树遍历一遍就可以求出最优解。</p>
<p>贪心和动态规划本质上其实是对子问题树的一种修剪。两种算法要求问题都具有的一个性质就是「子问题最优性」，也称为「最优子结构」。即，组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的。如果以自顶向下的方向看问题树，则，我们每次只需要向下遍历代表最优解的子树就可以保证会得到整体的最优解。形象一点说，可以简单的用一个值（最优值）代表整个子树，而不用去求出这个子树所可能代表的所有值。</p>
<h2 id="数塔问题"><a href="#数塔问题" class="headerlink" title="数塔问题"></a>数塔问题</h2><p>从顶部出发的每个节点可以向左或者向右，一直走到底层，要问走到第层的最大数字之和。<br>从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值，只有左右两道路径上的最大值求出来了才能作出决策。同样的道理，下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。这样一层一层推下去，直到倒数第二层时就非常明了。 </p>
<p>Dp本质：<br>最优子结构：即每个大的数塔必定包含很多小的数塔，要求解大数塔的最大值，肯定要选择小数塔中和最大的路径。<br>无后效性：这是判断一个问题能不能用dp做的重要标志之一；即某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。在数塔问题中，每次选择相加之和最大的节点，至于这个节点的和是怎么来的我不用管，也就是说“未来与过去无关”；但是如果说下一步的决策是受之前影响的（比如之前走过的点下一次就不能走了），那就叫有后效性，也就是：“未来受过去影响”。</p>
<p>深入一点地讲，我以为二者最本质的区别是：DP的选择策略是试探性的，每一步要试探所有的可行解并将结果保存起来，最后通过回溯的方法确定最优解，这也就是为什么DP解题一般采用自底向上的解法，形象地说，DP问题对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃（参考数塔问题）。而贪心算法每一次的都是对于局部最优进行选择，通过对候选解空间按照一定的规则进行排序，然后就可以按照这个排好的顺序进行选择了，选择过程中仅需确定当前元素是否要选取，与后面的元素是什么没有关系。形象地说，对于能够贪心的题，每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。通常这个值都是对于当前的问题情况下，显而易见的“最优”情况。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。</p>
<p>经过一顿分析，不难看出，能用贪心做的题都可以用DP做，反之则不一定。</p>
<p>因此，我们可以知道：满足贪心选择性质的问题可用贪心算法解决，不满足贪心选择性质的问题只能用动态规划解决。可见能用贪心算法解决的问题理论上都可以利用动态规划解决，而一旦证明贪心选择性质，用贪心算法解决问题往往比动态规划具有更低的时间复杂度和空间复杂度。为什么说是「往往」呢，我们后面再说。</p>
<h2 id="找钱问题"><a href="#找钱问题" class="headerlink" title="找钱问题"></a>找钱问题</h2><p>现有1，5，10，20，50，100面额的钱币，且每种面额的钱币的数量都足够多，那么如果让找出12块钱，绝大多数人会用一张10元的两张1元的来凑足12元。或许你没有察觉到，其实在这个过程中我们已经用到了贪心算法，不相信？那假如要找277元，该用几张1元的？我相信没人可以直接回答找277要用几张1元的，我们的思维方式都是想先用两张100的，剩77再用一张50的，最后确定用几张1元的。这就说明了贪心选择前的排序过程（既之前说的对候选解空间按照一定的规则进行排序），也就是说我们的贪心选择必须从大面值的开始，而不能从小面额的开始。每次拿能拿的最大的，这就是贪心。</p>
<p>现在假如钱币面额是1，5，12，那我们要找16元，还可以用贪心算法选择吗？显然不可以，3张5元1张一元才是张数最少的解。问题来了，为什么1，5，10，20就可以而1，5，12就不行呢？这就涉及「贪心选择性质」。</p>
<p>1，5，10，20满足贪心选择性质,而1，5，12就不满足。</p>
<p>要证明一个问题的贪心选择是否正确，往往我们通常是举反例来推翻其正确性,事实上大多数我们也是这样肝的。</p>
<p>对于贪心策略的证明理解起来难度不小，《算法导论》上对于贪心算法章节的描述也十分抽象，下面让我们引入一个引例：部分背包问题。</p>
<p>问题描述<br>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>问题分析<br>1.目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。<br>2.约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)<br>3.贪心策略：<br>选择价值最大的物品<br>选择价值最大的物品<br>选择单位重量价值最大的物品<br>有三个物品A,B,C，其重量分别为{30,10,20}，价值分别为{60,30,80}，背包的容量为50，分别应用三种贪心策略装入背包的物品和获得的价值如下图所示</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>20</td>
<td>60</td>
</tr>
<tr>
<td>B</td>
<td>30</td>
<td>120</td>
</tr>
<tr>
<td>C</td>
<td>10</td>
<td>50</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>物品</th>
<th>价值</th>
<th>重量</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>120</td>
<td>30</td>
</tr>
<tr>
<td>A</td>
<td>60</td>
<td>20</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">贪心策略1(按价值最大)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>物品</th>
<th>价值</th>
<th>重量</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>50</td>
<td>10</td>
</tr>
<tr>
<td>A</td>
<td>60</td>
<td>20</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">贪心策略2(按重量最小)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>物品</th>
<th>单位价值</th>
<th>重量</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>50/10=5</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>120/30=4</td>
<td>30</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">贪心策略3(按单位价值最大)</div></pre></td></tr></table></figure>
<p>显然，由于物品可分割，我们显然可以得出这样的结论：每次只需装入性价比最高的物品。为什么可以这样做呢？</p>
<p>我们将物品按照单位价值Vi/Wi从大到小排好序的，即：V1/W1 &gt;  V2/W2  &gt;  …  &gt;  Vn/Wn。</p>
<p>于是部分背包问题的贪心选择性质可以描述为：每次从Ci,j中选择物品，都是优先考虑选择物品i，且在满足条件1的情况下，Xi 越接近1越好。下面用数学归纳法证明这一贪心选择性质：</p>
<p>记Ai,j为从物品Ci,j中选择装进背包的最优解，则原问题为求A1,n。再记k为第k次从C中选物品进背包。则：</p>
<p>Ⅰ）当k=1时，满足贪心选择性质，即第一次选物品p进背包，且p=1。下面用反证法证明：</p>
<p>若p≠1，则p≥2。但在此情况下不能保证A1,n最优。试考虑W1=W的情况下，另外一个解A1,n’={1}的价值V’更大（因为V1/W1 &gt; V2/W2 &gt; …&gt; Vn/Wn）。既A1,n不是最优解，产生矛盾。所以p=1。</p>
<p>Ⅱ）在满足条件1的情况下，假设k≤z时，满足贪心选择性质。既前z（包括z）次从Cz,n中选择物品，都是优先考虑选择物品z，且在满足条件1的情况下，Xi 越接近1越好。</p>
<p>Ⅲ）在满足条件1的情况下，当k=z+1时，证明也满足贪心选择性质，既第k=z+1次选物品（z+1）。</p>
<p>先证明A1,n的子问题Az+1,n也具有最优性质：如果存在Cz+1,n中选择物品的子问题的解Az+1,n’的总价值比Az+1,n的总价值更大，那么Az+1,n’与A1,z合并后的原问题的解A1,n’的总价值比A1,n的总价值更大。这与A1,n是最优解矛盾。所以Az+1,n也具有最优性质。</p>
<p>于是第k=z+1次选择物品等价于子问题Az+1,n的第一次选择物品，又因为在Ⅱ）假设成立的情况下，C1,n的前z个物品已经被选了，所以转换成Az+1,n从Cz+1,n中选择第一个物品。根据Ⅰ），显然优先选择物品（z+1）。所以结论得证。</p>
<p>∴ 综合Ⅰ）Ⅱ）Ⅲ），得证部分背包问题具有最优选择性质。</p>
<p>以上，通过数学归纳法证明了部分背包问题的贪心选择正确性。那么推而广之，我们对于贪心问题正确性的证明步骤如下（的确有些抽象）</p>
<p>考察一个问题的最优解,证明可修改该最优解,使得其从贪心选择开始,然后用数学归纳法证明每一步都可以通过贪心选择得到最优解：<br>1,假定首选元素不是贪心选择所要的元素,证明将首元素替换成贪心选择所需元素,依然得到最优解；<br>2,数学归纳法证明每一步均可通过贪心选择得到最优解。</p>
<p>因此我们可以说，贪心选择性质即存在一个最优解是以贪心选择开始的。 也即：如果假设的全局最优解是第一个贪心选择，即成立；如果不是，则剪枝，然后将通过贪心选择的第一个粘贴上去，也就证明了无论什么情况都是从贪心选择开始的。</p>
<p>通过以上的分析，我们不难看出，贪心算法其实是动态规划方法的一个特例。贪心特在，我做一个决定的时候，不需要考虑这个决策对之后选择的影响，只需考虑当前最优，下一步的最优解由上一步的最优解推导得到；</p>
<p>比如对于0-1背包问题，既每个物品只能选择选或不选，贪心策略是有问题的。</p>
<p>为什么物体可以分割时能用贪心算法，而物体不能分割时就不行呢？这里想让大家注意一下「回退」的概念，这个需要「回退」的概念就是贪心选择性质失败的标志。</p>
<p>在背包问题中，如果物体可以分割，那我们装入单位质量最贵的东西“显然”是正确的，而如果物品不可分割，那就可能出现背包装了一个单价很贵的东西但没有装满，而后面一个虽然单价比较低但体积也比较大，这样就装不进去了，如果把前面那个东西倒出来把这个大的装进去可能就会使得总价值更大。总之这个问题在于背包可能装不满，而如果有一个物体单价低但占的空间更充分的话就有可能会得到更好的解。所以这个问题就需要往回试探的过程，这个就是要使用动态规划的标识。动态规划的选择策略就是试探性的，最后通过回溯的方法确定最优解，这是贪心算法不具备的。</p>
<p>再想一想找钱问题，因为两个7等于14，而选择10的时候我们并不知道后面有没有4可以选择，如果后面发现没有4再回头把10拿出来就会使整个搜索过程陷入混乱，贪心算法不允许“往回拿”的操作，通俗点讲，贪心就是“一锤子买卖”，这也正是贪心策略失效的原因。</p>
<p>但是我们必须要意识到，贪心算法是优化了选择的策略，而非与动态规划背道而驰，贪心算法仅仅是动态规划的一个平凡态罢了。一般情况下，我们认为贪心是对动规的一种优化，因此，对于一个给定问题，先对问题的解空间建模，如果得到最优子结构的性质，写出状态转移方程，再看某些维度是否有贪心的优化余地。</p>
<p>如果问题可以选择贪心做法，一般情况下我们会选择贪心，但是话说回来，既然是研究一个算法，必然要分析一下其时间复杂度与空间复杂度。那么，是不是对于所有具有最优子结构的问题，在能选择贪心优化时都要选择贪心呢？未必哦。贪心算法确实可能比其对应的动态规划快不少，因为它的常数可能小得多。并且在思维难度上，贪心比动规简单了不少 。</p>
<p>为了直观一点地验证这一结论，下面贴上0-1背包和部分背包的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    </div><div class="line">    int w[maxn],v[maxn];//w为质量，v为价值，r为价值与质量的比</div><div class="line">    float r[maxn];//r为价值与质量的比</div><div class="line">    int n;//物品的数量</div><div class="line">    int m; //背包的容量</div><div class="line">    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);   //输入背包总量和数量</div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        scanf(&quot;%d %d&quot;,&amp;w[i],&amp;v[i]);</div><div class="line">    &#125;</div><div class="line">    for(int i=0; i&lt;n; i++)&#123;</div><div class="line">        r[i]=v[i]*1.0/w[i];</div><div class="line">    &#125;</div><div class="line">    for(int i=1;i&lt;n;i++)&#123;</div><div class="line">        for(int j=0;j&lt;n-i;j++)&#123;</div><div class="line">            if(r[j]&lt;r[j+1])&#123;</div><div class="line">                int x;</div><div class="line">                double y;</div><div class="line">                y=r[j];r[j]=r[j+1];r[j+1]=y;</div><div class="line">                x=w[j];w[j]=w[j+1];w[j+1]=x;</div><div class="line">                x=v[j];v[j]=v[j+1];v[j+1]=x;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int i=0;</div><div class="line">    while(m)&#123;</div><div class="line">        if(w[i]&lt;=m)&#123;</div><div class="line">            m-=w[i];</div><div class="line">            printf(&quot;价值：%d取：%d\n&quot;,v[i],w[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            printf(&quot;价值：%d取：%d\n&quot;,v[i],m);</div><div class="line">            m=0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>0-1背包</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int T,n,bag;</div><div class="line">    int dp[maxn],v[maxn],w[maxn];</div><div class="line">    while(cin&gt;&gt;T)</div><div class="line">    &#123;</div><div class="line">        while(T--)</div><div class="line">        &#123;</div><div class="line">            memset(v,0,sizeof(v));</div><div class="line">            memset(w,0,sizeof(w));</div><div class="line">            memset(dp,0,sizeof(dp));</div><div class="line">            cin&gt;&gt;n&gt;&gt;bag;</div><div class="line">            for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i];</div><div class="line">            for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i];</div><div class="line">            for(int i=0;i&lt;n;i++)</div><div class="line">                for(int j=bag;j&gt;=w[i];j—)//完全背包则正序循环  </div><div class="line">                &#123;</div><div class="line">                    dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</div><div class="line">                &#125;</div><div class="line">            cout&lt;&lt;dp[bag]&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从以上的对比可以看出：DP的代码十分简洁，但是理解起来的难度不小，不像贪心那样通俗易懂。</p>
<p>一般地，在算法竞赛中，我们采用如下的优化策略：</p>
<blockquote>
<p>优化与否取决于动态规划中计算所有可选的策略的代价，如果代价是常数的，那么将其贪心优化并不会带来时间复杂度的下降，该走的解空间还是要走，只是不保存其中的一些值而已，可能会带来空间复杂度的下降。</p>
</blockquote>
<p>以上已经是进阶操作了（稍微有点超纲），需要有比较扎实的算法基础和相当大的刷题量，还需要读者慢慢体会。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>算法浅谈</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS && BFS</title>
    <url>/2019/11/24/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>搜索就是通过不停的试探去寻找一种解法。基础：暴力搜索法，深搜和广搜三种<br>高级的有IDDFS,DBFS,A<em>,IDA</em>等等，本蒻今天讲DFS &amp;&amp; BFS。</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="算法过程-DFS-状态-A"><a href="#算法过程-DFS-状态-A" class="headerlink" title="算法过程 DFS(状态 A)"></a>算法过程 DFS(状态 A)</h2><h3 id="1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"><a href="#1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。" class="headerlink" title="1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"></a>1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。</h3><h3 id="2-调用DFS-状态A-t-即先走下一层。"><a href="#2-调用DFS-状态A-t-即先走下一层。" class="headerlink" title="2.调用DFS(状态A+t) 即先走下一层。"></a>2.调用DFS(状态A+t) 即先走下一层。</h3><h2 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h2><p><a href="http://codeforces.com/gym/102394/problem/F" target="_blank" rel="external">CCPC2019哈尔滨站</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p> 六个字符串，从每个字符串中取出一个字符，问能否构成”harbin”？如果能构<br> 则输出”Yes”,否则输出”No”。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>  多组测试，第一个数字 T 代表测试组数<br>  每组测试输入6个字符串<br>  所有字符串长度之和不超过 2e6</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>  每组测试输出”Yes”或”No”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">char s[2002000];</div><div class="line">bool mp[7][7];</div><div class="line">bool a[7];</div><div class="line">bool dfs(int p)</div><div class="line">&#123;</div><div class="line">	if(p == 7) return true;</div><div class="line">	for(int i = 1; i &lt;= 6; ++i)</div><div class="line">	&#123;</div><div class="line">		if(mp[p][i] &amp;&amp; a[i])</div><div class="line">		&#123;</div><div class="line">			a[i] = 0;</div><div class="line">			if(dfs(p + 1)) return true;</div><div class="line">			a[i] = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return false;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int T;</div><div class="line">	scanf(&quot;%d&quot;,&amp;T);</div><div class="line">	while(T--)</div><div class="line">    &#123;</div><div class="line">		memset(mp,0,sizeof(mp));</div><div class="line">		memset(a,1,sizeof(a));</div><div class="line">		for(int i = 1; i &lt;= 6; ++i)</div><div class="line">        &#123;</div><div class="line">			scanf(&quot;%s&quot;,s);</div><div class="line">			int len = strlen(s);</div><div class="line">			for(int j = 0; j &lt; len; ++j)</div><div class="line">				if(s[j] == &apos;h&apos;)</div><div class="line">					mp[i][1] = 1;</div><div class="line">				else if(s[j] == &apos;a&apos;)</div><div class="line">					mp[i][2] = 1;</div><div class="line">				else if(s[j] == &apos;r&apos;)</div><div class="line">					mp[i][3] = 1;</div><div class="line">				else if(s[j] == &apos;b&apos;)</div><div class="line">					mp[i][4] = 1;</div><div class="line">				else if(s[j] == &apos;i&apos;)</div><div class="line">					mp[i][5] = 1;</div><div class="line">				else if(s[j] == &apos;n&apos;)</div><div class="line">					mp[i][6] = 1;</div><div class="line">        &#125;</div><div class="line">		if(dfs(1))</div><div class="line">			printf(&quot;Yes\n&quot;);</div><div class="line">		else</div><div class="line">			printf(&quot;No\n&quot;);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h2><h3 id="题面描述-简单版本"><a href="#题面描述-简单版本" class="headerlink" title="题面描述(简单版本)"></a>题面描述(简单版本)</h3><p> 有一个 n行m列 的网格，每个格子里非 0 即 1，有 q 次操作，每次<br> 给定一个以(x1,y1)为左上角，(x2,y2)为右下角的矩形内所有格子里<br> 的数字都变成1。问每次操作之后，所有数字为 1 的格子构成的四连通<br> 块的个数。</p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入第一行两个整数 n,m(1 &lt;= n,m &lt;= 300),表示网格的大小。<br>接下来 n 行，每行一个长为 m 的 01串，表示初始网格大小。<br>接下来一行一个整数 q, 表示操作个数。<br>接下来 q 行，每行四个整数 x1, y1, x2, y2(1&lt;=x1&lt;=x2&lt;=n,1&lt;=y1&lt;=y2&lt;=m)<br>表示把以(x1,y1)为左上角，(x2,y2)为右下角的矩形中的元素都变为1。</p>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出共 q 行，每行一个整数，表示每次操作后含有数字1的格子构成的四连通块个数</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5 6<br>101010<br>000001<br>101010<br>000001<br>101010<br>3<br>1 2 5 2<br>4 4 4 4<br>1 3 3 6</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>6<br>7<br>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 350;</div><div class="line">char mp[maxn][maxn],flag[maxn][maxn];</div><div class="line">int head[4][2]=&#123;&#123;0,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;</div><div class="line">int n, m ,q, ans;</div><div class="line"></div><div class="line">bool inbound(int x, int y)</div><div class="line">&#123;</div><div class="line">    if(x&gt;=1 &amp;&amp; x &lt;= n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m)</div><div class="line">        return true;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dfs(int x,int y)</div><div class="line">&#123;</div><div class="line">    mp[x][y] = &apos;0&apos;;</div><div class="line">    for(int i = 0; i &lt; 4; i++)</div><div class="line">    &#123;</div><div class="line">        int dx = x + head[i][0];</div><div class="line">        int dy = y + head[i][1];</div><div class="line">        if(mp[dx][dy]==&apos;1&apos; &amp;&amp; inbound(dx,dy))</div><div class="line">        &#123;</div><div class="line">            mp[dx][dy] = &apos;0&apos;;</div><div class="line">            dfs(dx,dy);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	cin&gt;&gt;n&gt;&gt;m;</div><div class="line">	for(int i = 1; i &lt;= n; i++)</div><div class="line">	    for(int j = 1; j &lt;= m; j++)</div><div class="line">	        cin&gt;&gt;mp[i][j];</div><div class="line">	cin&gt;&gt;q;</div><div class="line">	while(q--)</div><div class="line">	&#123;</div><div class="line">	    ans = 0;</div><div class="line">		int x1, y1, x2, y2;</div><div class="line">		cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</div><div class="line">		for(int i = x1; i &lt;= x2; i++)</div><div class="line">            for(int j = y1; j &lt;= y2; j++)</div><div class="line">                mp[i][j] = &apos;1&apos;;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                flag[i][j]=mp[i][j];</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">	        for(int j = 1; j &lt;= m; j++)</div><div class="line">	        &#123;</div><div class="line">	            if(mp[i][j] == &apos;1&apos;)</div><div class="line">                &#123;</div><div class="line">                    ans++;</div><div class="line">                    dfs(i,j);</div><div class="line">                &#125;</div><div class="line">	        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                mp[i][j]=flag[i][j];</div><div class="line">        printf(&quot;%d\n&quot;,ans);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="算法过程-广度优先搜索"><a href="#算法过程-广度优先搜索" class="headerlink" title="算法过程(广度优先搜索)"></a>算法过程(广度优先搜索)</h2><h3 id="1-一层一层的走"><a href="#1-一层一层的走" class="headerlink" title="1.一层一层的走"></a>1.一层一层的走</h3><h3 id="2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来"><a href="#2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来" class="headerlink" title="2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来"></a>2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来</h3><h3 id="3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"><a href="#3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并" class="headerlink" title="3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"></a>3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并</h3><p>且以这个状态为”根节点”进行广度优先搜索。</p>
<h3 id="4-直到整个队列为空。"><a href="#4-直到整个队列为空。" class="headerlink" title="4.直到整个队列为空。"></a>4.直到整个队列为空。</h3><h2 id="习题三-走迷宫-Bfs"><a href="#习题三-走迷宫-Bfs" class="headerlink" title="习题三 走迷宫(Bfs)"></a>习题三 走迷宫(Bfs)</h2><h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h3><p> 一个 n行 m 列的迷宫，迷宫的格子里分别放 0 和 1，1 表示可以通过，0表<br> 示不可以通过。<br> 从某个点开始，有四个方向可以走，前进方格中的数字为 1 时表示可以通过，<br> 0表示不可通过，要另找路径。<br> 起点是左上角，输入终点坐标，给出最短路径。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>6 5 6 5<br>1 0 0 0 0<br>1 1 1 1 1<br>0 0 0 0 1<br>1 1 1 1 1<br>1 0 0 0 0<br>1 1 1 1 1</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>17<br>(11)(21)-&gt;(22)-&gt;(23)-&gt;(24)-&gt;(25)-&gt;(35)-&gt;(45)-&gt;(44)-&gt;(43)-&gt;(42)-&gt;(41)-&gt;(51)-&gt;(61)-&gt;(62)-&gt;(63)-&gt;(64)-&gt;(65)-&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n,m,tx,ty;</div><div class="line">int mp[110][110];</div><div class="line">int qu[10010];  //模拟队列，存所有的点</div><div class="line">int l,r;    //[l,r)</div><div class="line">int dis[110][110];  //dis[][]表示这个点是否被访问过</div><div class="line">int pre[10010];  //pre[]记录方案</div><div class="line">int dir[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</div><div class="line">bool inbound(int x, int l, int r)</div><div class="line">&#123;</div><div class="line">    if(x &lt; l || x &gt;= r)</div><div class="line">        return false;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void write(int s,int x)</div><div class="line">&#123;</div><div class="line">    if(s == x)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;(%d%d)&quot;,s/m+1,s%m+1);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    write(s,pre[x]);</div><div class="line">    printf(&quot;(%d%d)-&gt;&quot;,x/m+1,x%m+1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void bfs(int s, int t)</div><div class="line">&#123;</div><div class="line">    memset(dis,-1,sizeof(dis));</div><div class="line">    memset(qu,0,sizeof(qu));</div><div class="line">    l = 0; r = 0;</div><div class="line">    qu[0] = s;  //起点存入队列</div><div class="line">    r++;   //保证区间左闭右开</div><div class="line">    dis[s/m][s%m] = 0;</div><div class="line">    while(l &lt; r)</div><div class="line">    &#123;</div><div class="line">        int point = qu[l];  //取出队首元素</div><div class="line">        if(point == t) break;   //到达终点，提前退出</div><div class="line">        l++;  //出队</div><div class="line">        int x = point/m, y = point%m;  //点的位置</div><div class="line">        for(int i = 0; i &lt; 4; i++)   //四个方向扩展</div><div class="line">        &#123;</div><div class="line">            int tx = x + dir[i][0];</div><div class="line">            int ty = y + dir[i][1];</div><div class="line">            if(!inbound(tx,0,n)||!inbound(ty,0,m))</div><div class="line">                continue;</div><div class="line">            if(dis[tx][ty] == -1 &amp;&amp; mp[tx][ty] == 1)</div><div class="line">            &#123;</div><div class="line">                dis[tx][ty] = dis[x][y] + 1;  //(x,y)--&gt;(tx,ty)</div><div class="line">                pre[tx*m+ty] = point; //记录前驱</div><div class="line">                qu[r] = tx*m+ty;  //放入队列</div><div class="line">                r++;   //进队</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,dis[t/m][t%m]);</div><div class="line">    write(s,t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d%d&quot;, &amp;n,&amp;m);</div><div class="line">    scanf(&quot; %d%d&quot;, &amp;tx,&amp;ty);</div><div class="line">    for(int i = 0; i &lt; n; i++)</div><div class="line">        for(int j = 0; j &lt; m; j++)</div><div class="line">            scanf(&quot; %d&quot;, &amp;mp[i][j]);</div><div class="line">    tx--;ty--;</div><div class="line">    bfs(0 ,tx*m+ty);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>搜索解决问题：</em><br>在一个空间中寻找目标<br>空间指的是解空间<br>目标是指目标状态<br>解空间：如果把一个问题的抽象成一个数学上的向量，那么包含这个向量<br>空间，也就是解空间。<br>状态：用于描述问题或问题解的一些向量。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2019/11/23/STL/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包</title>
    <url>/2019/11/21/01%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p> 有 n 件物品和容量是 V 的背包。每件物品只能取一次。每件物品有自<br> 己的体积和价值。在不超过背包容积的状态下，问背包能够容纳的最大<br> 价值是多少？</p>
<p> <strong>输入格式</strong><br> 第一行两个整数 n,v,分别代表物品的数量和背包的容积。接下来 n行,<br> 每行两个整数，分别代表物品的体积和价值</p>
<p> <strong>输出格式</strong><br> 输出一个整数，表示最大价值。</p>
<p> <strong>数据范围</strong><br> 0 &lt; N,V&lt;= 1000;<br> 0 &lt; w, value &lt;= 1000;</p>
<p><strong>输入样例</strong><br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p>
<p><strong>输出样例</strong><br>8</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="确定状态"><a href="#确定状态" class="headerlink" title="确定状态"></a>确定状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][j]:表示前i个物品体积为j的背包,能够容纳价值多大的商品。</div></pre></td></tr></table></figure>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">如果背包当前体积小于物品的体积，就不选这个物品，即:</div><div class="line">--&gt;  dp[i][j] = dp[i-1][j];</div><div class="line">如果背包当前体积大于或等于物品的体积,就选择这个物品,即:</div><div class="line">--&gt;  dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+value[i])</div><div class="line">dp[i-1][j]的含义：前 i- 1个物品放入容量为j的背包所能够容纳的</div><div class="line">最大价值。</div><div class="line">dp[i-1][j-w[i]]+value[i]含义:前 i - 1个物品放入容量为j-w[i]</div><div class="line">的背包所能够容纳的最大价值。</div></pre></td></tr></table></figure>
<h2 id="确定编码实现方式"><a href="#确定编码实现方式" class="headerlink" title="确定编码实现方式"></a>确定编码实现方式</h2><h3 id="未优化代码：二维数组的实现"><a href="#未优化代码：二维数组的实现" class="headerlink" title="未优化代码：二维数组的实现"></a>未优化代码：二维数组的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 1e3 + 7;</div><div class="line">int n,v;</div><div class="line">int w[maxn],value[maxn];</div><div class="line">int dp[maxn][maxn];</div><div class="line">int mian()</div><div class="line">&#123;</div><div class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;v))</div><div class="line">	&#123;</div><div class="line">		memset(w,0,sizeof(w));</div><div class="line">		memset(value,0,sizeof(value));</div><div class="line">		memset(dp,0,sizeof(dp));</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;value[i]);</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++)</div><div class="line">		&#123;</div><div class="line">			for(int j = v; j &gt;= 0; --j)</div><div class="line">			&#123;</div><div class="line">				if(j &gt;= w[i])</div><div class="line">				    dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+value[i]);</div><div class="line">				else</div><div class="line">				    dp[i][j] = dp[i-1][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;,dp[n][v]);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化版本，一维数组实现"><a href="#优化版本，一维数组实现" class="headerlink" title="优化版本，一维数组实现"></a>优化版本，一维数组实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 1e3 + 7;</div><div class="line">int n,v;</div><div class="line">int w[maxn],value[maxn];</div><div class="line">int dp[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;v))</div><div class="line">	&#123;</div><div class="line">		memset(w,0,sizeof(w));</div><div class="line">		memset(value,0,sizeof(value));</div><div class="line">		memset(dp,0,sizeof(dp));</div><div class="line">		for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;value[i]);</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++)</div><div class="line">		    for(int j = v; j &gt;= w[i]; --j)</div><div class="line">		        dp[j] = max(dp[j],dp[j-w[i]]+value[i]);</div><div class="line">		//体积为 j 的背包容纳的最大价值。</div><div class="line">		//体积为 j - w[i] 的背包容纳的最大价值。</div><div class="line">		printf(&quot;%d\n&quot;,dp[v]);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="动态规划一般的解题三部曲"><a href="#动态规划一般的解题三部曲" class="headerlink" title="动态规划一般的解题三部曲"></a>动态规划一般的解题三部曲</h1><h2 id="确定状态-1"><a href="#确定状态-1" class="headerlink" title="确定状态"></a>确定状态</h2><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><h2 id="确定编码实现方式-1"><a href="#确定编码实现方式-1" class="headerlink" title="确定编码实现方式"></a>确定编码实现方式</h2>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC打铁记</title>
    <url>/2019/11/18/ICPC%E6%89%93%E9%93%81/</url>
    <content><![CDATA[<h1 id="十一月十六"><a href="#十一月十六" class="headerlink" title="十一月十六"></a>十一月十六</h1><p> 沈阳的十一月大雪过后已是寒风凛至,头天马<br> 哥和王哥带俺去东北大学报道，报道结束,已<br> 经是上午十一点过,然后我提议去食堂觅食，<br> 然后我们就径直前去食堂。饭后，马哥的朋友<br> 带我们去寻找空教室休息。东大是我第一次在<br> 大学里看到拥有人脸支付功能的售货机。在这<br> 里点评东大的饭是真的好吃,本来这次打算和<br> 周哥他们见一面,后来想想，日后有缘自会相<br> 见。最后热生赛后我们一起去吃晚饭，然后回<br> 校。</p>
<h1 id="十一月十七"><a href="#十一月十七" class="headerlink" title="十一月十七"></a>十一月十七</h1><p> 正式赛那天早晨我很心慌,这一切来源我数学<br> 没看完,只把算法基础课的数学部分全部看完<br> 以及好好研究了一下博弈类型的题,然后把毛<br> 毛雨学姐发给我的数学看了一部分,正式赛中<br> 我发现我的问题,我发现平时思维题做多了,<br> 现在就只习惯思维题。ICPC我认识到自己是真<br> 的菜,在明年的省赛，蓝桥杯以及四省赛前我<br> 要提升自己，从一个量变到质变的过程。那晚<br> 我想了一晚上,我不能让”双非”成为我这一生<br> 的痛点，我要考研。考往西安电子科技大学，<br> 如果问我为什么不回成都呢？答案很简单，<br> 我向往自由，对于找对象这件事我现在没什<br> 么兴趣了，一切随缘。对于我两次高考的失败<br> 其实我早已意识到自己存在的毛病,但是我却<br> 一直逃避。做事情一旦遇见外界的干扰我就选<br> 择放弃，然后自嘲”自己时运不济，老天喜欢<br> 和我开玩笑”,其实如果当初我自律,现在我至<br> 少在读大三，不用为未来担忧。现在以及未来<br> 我要做我自己，他人用什么态度对待我,我将<br> 以什么态度对待他人。也许我会很高冷，也许<br> 让人看不懂，拥有自己的棱角。在此，感谢马<br> 哥和王哥带我一起去参加ICPC。未来在算法竞<br> 赛这条路上不拿牌子我不弃坑，至少在省赛和<br> 东北四省赛中取得牌子，惟愿我能找到我的快<br> 乐。</p>
]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>感谢岁月</tag>
      </tags>
  </entry>
</search>
