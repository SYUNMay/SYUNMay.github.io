<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS && BFS</title>
    <url>/2019/11/24/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>搜索就是通过不停的试探去寻找一种解法。基础：暴力搜索法，深搜和广搜三种<br>高级的有IDDFS,DBFS,A<em>,IDA</em>等等，本蒻今天讲DFS &amp;&amp; BFS。</p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="算法过程-DFS-状态-A"><a href="#算法过程-DFS-状态-A" class="headerlink" title="算法过程 DFS(状态 A)"></a>算法过程 DFS(状态 A)</h2><h3 id="1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"><a href="#1-判断当前状态是否合法。合法则继续执行，否则回到上一次调用。" class="headerlink" title="1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。"></a>1.判断当前状态是否合法。合法则继续执行，否则回到上一次调用。</h3><h3 id="2-调用DFS-状态A-t-即先走下一层。"><a href="#2-调用DFS-状态A-t-即先走下一层。" class="headerlink" title="2.调用DFS(状态A+t) 即先走下一层。"></a>2.调用DFS(状态A+t) 即先走下一层。</h3><h2 id="习题1"><a href="#习题1" class="headerlink" title="习题1"></a>习题1</h2><p><a href="http://codeforces.com/gym/102394/problem/F" target="_blank" rel="external">CCPC2019哈尔滨站</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p> 六个字符串，从每个字符串中取出一个字符，问能否构成”harbin”？如果能构<br> 则输出”Yes”,否则输出”No”。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>  多组测试，第一个数字 T 代表测试组数<br>  每组测试输入6个字符串<br>  所有字符串长度之和不超过 2e6</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>  每组测试输出”Yes”或”No”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">char s[2002000];</div><div class="line">bool mp[7][7];</div><div class="line">bool a[7];</div><div class="line">bool dfs(int p)</div><div class="line">&#123;</div><div class="line">	if(p == 7) return true;</div><div class="line">	for(int i = 1; i &lt;= 6; ++i)</div><div class="line">	&#123;</div><div class="line">		if(mp[p][i] &amp;&amp; a[i])</div><div class="line">		&#123;</div><div class="line">			a[i] = 0;</div><div class="line">			if(dfs(p + 1)) return true;</div><div class="line">			a[i] = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return false;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int T;</div><div class="line">	scanf(&quot;%d&quot;,&amp;T);</div><div class="line">	while(T--)</div><div class="line">    &#123;</div><div class="line">		memset(mp,0,sizeof(mp));</div><div class="line">		memset(a,1,sizeof(a));</div><div class="line">		for(int i = 1; i &lt;= 6; ++i)</div><div class="line">        &#123;</div><div class="line">			scanf(&quot;%s&quot;,s);</div><div class="line">			int len = strlen(s);</div><div class="line">			for(int j = 0; j &lt; len; ++j)</div><div class="line">				if(s[j] == &apos;h&apos;)</div><div class="line">					mp[i][1] = 1;</div><div class="line">				else if(s[j] == &apos;a&apos;)</div><div class="line">					mp[i][2] = 1;</div><div class="line">				else if(s[j] == &apos;r&apos;)</div><div class="line">					mp[i][3] = 1;</div><div class="line">				else if(s[j] == &apos;b&apos;)</div><div class="line">					mp[i][4] = 1;</div><div class="line">				else if(s[j] == &apos;i&apos;)</div><div class="line">					mp[i][5] = 1;</div><div class="line">				else if(s[j] == &apos;n&apos;)</div><div class="line">					mp[i][6] = 1;</div><div class="line">        &#125;</div><div class="line">		if(dfs(1))</div><div class="line">			printf(&quot;Yes\n&quot;);</div><div class="line">		else</div><div class="line">			printf(&quot;No\n&quot;);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a>习题2</h2><h3 id="题面描述-简单版本"><a href="#题面描述-简单版本" class="headerlink" title="题面描述(简单版本)"></a>题面描述(简单版本)</h3><p> 有一个 n行m列 的网格，每个格子里非 0 即 1，有 q 次操作，每次<br> 给定一个以(x1,y1)为左上角，(x2,y2)为右下角的矩形内所有格子里<br> 的数字都变成1。问每次操作之后，所有数字为 1 的格子构成的四连通<br> 块的个数。</p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入第一行两个整数 n,m(1 &lt;= n,m &lt;= 300),表示网格的大小。<br>接下来 n 行，每行一个长为 m 的 01串，表示初始网格大小。<br>接下来一行一个整数 q, 表示操作个数。<br>接下来 q 行，每行四个整数 x1, y1, x2, y2(1&lt;=x1&lt;=x2&lt;=n,1&lt;=y1&lt;=y2&lt;=m)<br>表示把以(x1,y1)为左上角，(x2,y2)为右下角的矩形中的元素都变为1。</p>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出共 q 行，每行一个整数，表示每次操作后含有数字1的格子构成的四连通块个数</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5 6<br>101010<br>000001<br>101010<br>000001<br>101010<br>3<br>1 2 5 2<br>4 4 4 4<br>1 3 3 6</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>6<br>7<br>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 350;</div><div class="line">char mp[maxn][maxn],flag[maxn][maxn];</div><div class="line">int head[4][2]=&#123;&#123;0,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;&#125;;</div><div class="line">int n, m ,q, ans;</div><div class="line"></div><div class="line">bool inbound(int x, int y)</div><div class="line">&#123;</div><div class="line">    if(x&gt;=1 &amp;&amp; x &lt;= n &amp;&amp; y&gt;=1 &amp;&amp; y&lt;=m)</div><div class="line">        return true;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dfs(int x,int y)</div><div class="line">&#123;</div><div class="line">    mp[x][y] = &apos;0&apos;;</div><div class="line">    for(int i = 0; i &lt; 4; i++)</div><div class="line">    &#123;</div><div class="line">        int dx = x + head[i][0];</div><div class="line">        int dy = y + head[i][1];</div><div class="line">        if(mp[dx][dy]==&apos;1&apos; &amp;&amp; inbound(dx,dy))</div><div class="line">        &#123;</div><div class="line">            mp[dx][dy] = &apos;0&apos;;</div><div class="line">            dfs(dx,dy);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	cin&gt;&gt;n&gt;&gt;m;</div><div class="line">	for(int i = 1; i &lt;= n; i++)</div><div class="line">	    for(int j = 1; j &lt;= m; j++)</div><div class="line">	        cin&gt;&gt;mp[i][j];</div><div class="line">	cin&gt;&gt;q;</div><div class="line">	while(q--)</div><div class="line">	&#123;</div><div class="line">	    ans = 0;</div><div class="line">		int x1, y1, x2, y2;</div><div class="line">		cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</div><div class="line">		for(int i = x1; i &lt;= x2; i++)</div><div class="line">            for(int j = y1; j &lt;= y2; j++)</div><div class="line">                mp[i][j] = &apos;1&apos;;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                flag[i][j]=mp[i][j];</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">	        for(int j = 1; j &lt;= m; j++)</div><div class="line">	        &#123;</div><div class="line">	            if(mp[i][j] == &apos;1&apos;)</div><div class="line">                &#123;</div><div class="line">                    ans++;</div><div class="line">                    dfs(i,j);</div><div class="line">                &#125;</div><div class="line">	        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for(int i = 1; i &lt;= n; i++)</div><div class="line">            for(int j = 1; j &lt;= m; j++)</div><div class="line">                mp[i][j]=flag[i][j];</div><div class="line">        printf(&quot;%d\n&quot;,ans);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="算法过程-广度优先搜索"><a href="#算法过程-广度优先搜索" class="headerlink" title="算法过程(广度优先搜索)"></a>算法过程(广度优先搜索)</h2><h3 id="1-一层一层的走"><a href="#1-一层一层的走" class="headerlink" title="1.一层一层的走"></a>1.一层一层的走</h3><h3 id="2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来"><a href="#2-广搜总是每次都把离上一状态最近的状态用一个队列记录下来" class="headerlink" title="2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来"></a>2.广搜总是每次都把离上一状态最近的状态用一个队列记录下来</h3><h3 id="3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"><a href="#3-记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并" class="headerlink" title="3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并"></a>3.记录之后，检查队列是否为空，如果不为空，就将队列元素弹出，并</h3><p>且以这个状态为”根节点”进行广度优先搜索。</p>
<h3 id="4-直到整个队列为空。"><a href="#4-直到整个队列为空。" class="headerlink" title="4.直到整个队列为空。"></a>4.直到整个队列为空。</h3><h2 id="习题三-走迷宫-Bfs"><a href="#习题三-走迷宫-Bfs" class="headerlink" title="习题三 走迷宫(Bfs)"></a>习题三 走迷宫(Bfs)</h2><h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h3><p> 一个 n行 m 列的迷宫，迷宫的格子里分别放 0 和 1，1 表示可以通过，0表<br> 示不可以通过。<br> 从某个点开始，有四个方向可以走，前进方格中的数字为 1 时表示可以通过，<br> 0表示不可通过，要另找路径。<br> 起点是左上角，输入终点坐标，给出最短路径。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>6 5 6 5<br>1 0 0 0 0<br>1 1 1 1 1<br>0 0 0 0 1<br>1 1 1 1 1<br>1 0 0 0 0<br>1 1 1 1 1</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>17<br>(11)(21)-&gt;(22)-&gt;(23)-&gt;(24)-&gt;(25)-&gt;(35)-&gt;(45)-&gt;(44)-&gt;(43)-&gt;(42)-&gt;(41)-&gt;(51)-&gt;(61)-&gt;(62)-&gt;(63)-&gt;(64)-&gt;(65)-&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">int n,m,tx,ty;</div><div class="line">int mp[110][110];</div><div class="line">int qu[10010];  //模拟队列，存所有的点</div><div class="line">int l,r;    //[l,r)</div><div class="line">int dis[110][110];  //dis[][]表示这个点是否被访问过</div><div class="line">int pre[10010];  //pre[]记录方案</div><div class="line">int dir[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</div><div class="line">bool inbound(int x, int l, int r)</div><div class="line">&#123;</div><div class="line">    if(x &lt; l || x &gt;= r)</div><div class="line">        return false;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void write(int s,int x)</div><div class="line">&#123;</div><div class="line">    if(s == x)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;(%d%d)&quot;,s/m+1,s%m+1);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    write(s,pre[x]);</div><div class="line">    printf(&quot;(%d%d)-&gt;&quot;,x/m+1,x%m+1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void bfs(int s, int t)</div><div class="line">&#123;</div><div class="line">    memset(dis,-1,sizeof(dis));</div><div class="line">    memset(qu,0,sizeof(qu));</div><div class="line">    l = 0; r = 0;</div><div class="line">    qu[0] = s;  //起点存入队列</div><div class="line">    r++;   //保证区间左闭右开</div><div class="line">    dis[s/m][s%m] = 0;</div><div class="line">    while(l &lt; r)</div><div class="line">    &#123;</div><div class="line">        int point = qu[l];  //取出队首元素</div><div class="line">        if(point == t) break;   //到达终点，提前退出</div><div class="line">        l++;  //出队</div><div class="line">        int x = point/m, y = point%m;  //点的位置</div><div class="line">        for(int i = 0; i &lt; 4; i++)   //四个方向扩展</div><div class="line">        &#123;</div><div class="line">            int tx = x + dir[i][0];</div><div class="line">            int ty = y + dir[i][1];</div><div class="line">            if(!inbound(tx,0,n)||!inbound(ty,0,m))</div><div class="line">                continue;</div><div class="line">            if(dis[tx][ty] == -1 &amp;&amp; mp[tx][ty] == 1)</div><div class="line">            &#123;</div><div class="line">                dis[tx][ty] = dis[x][y] + 1;  //(x,y)--&gt;(tx,ty)</div><div class="line">                pre[tx*m+ty] = point; //记录前驱</div><div class="line">                qu[r] = tx*m+ty;  //放入队列</div><div class="line">                r++;   //进队</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;,dis[t/m][t%m]);</div><div class="line">    write(s,t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    scanf(&quot;%d%d&quot;, &amp;n,&amp;m);</div><div class="line">    scanf(&quot; %d%d&quot;, &amp;tx,&amp;ty);</div><div class="line">    for(int i = 0; i &lt; n; i++)</div><div class="line">        for(int j = 0; j &lt; m; j++)</div><div class="line">            scanf(&quot; %d&quot;, &amp;mp[i][j]);</div><div class="line">    tx--;ty--;</div><div class="line">    bfs(0 ,tx*m+ty);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>搜索解决问题：</em><br>在一个空间中寻找目标<br>空间指的是解空间<br>目标是指目标状态<br>解空间：如果把一个问题的抽象成一个数学上的向量，那么包含这个向量<br>空间，也就是解空间。<br>状态：用于描述问题或问题解的一些向量。</p>
]]></content>
      <categories>
        <category>ACM入门</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2019/11/23/STL/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ACM入门</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包</title>
    <url>/2019/11/21/01%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p> 有 n 件物品和容量是 V 的背包。每件物品只能取一次。每件物品有自<br> 己的体积和价值。在不超过背包容积的状态下，问背包能够容纳的最大<br> 价值是多少？</p>
<p> <strong>输入格式</strong><br> 第一行两个整数 n,v,分别代表物品的数量和背包的容积。接下来 n行,<br> 每行两个整数，分别代表物品的体积和价值</p>
<p> <strong>输出格式</strong><br> 输出一个整数，表示最大价值。</p>
<p> <strong>数据范围</strong><br> 0 &lt; N,V&lt;= 1000;<br> 0 &lt; w, value &lt;= 1000;</p>
<p><strong>输入样例</strong><br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p>
<p><strong>输出样例</strong><br>8</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="确定状态"><a href="#确定状态" class="headerlink" title="确定状态"></a>确定状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dp[i][j]:表示前i个物品体积为j的背包,能够容纳价值多大的商品。</div></pre></td></tr></table></figure>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">如果背包当前体积小于物品的体积，就不选这个物品，即:</div><div class="line">--&gt;  dp[i][j] = dp[i-1][j];</div><div class="line">如果背包当前体积大于或等于物品的体积,就选择这个物品,即:</div><div class="line">--&gt;  dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+value[i])</div><div class="line">dp[i-1][j]的含义：前 i- 1个物品放入容量为j的背包所能够容纳的</div><div class="line">最大价值。</div><div class="line">dp[i-1][j-w[i]]+value[i]含义:前 i - 1个物品放入容量为j-w[i]</div><div class="line">的背包所能够容纳的最大价值。</div></pre></td></tr></table></figure>
<h2 id="确定编码实现方式"><a href="#确定编码实现方式" class="headerlink" title="确定编码实现方式"></a>确定编码实现方式</h2><h3 id="未优化代码：二维数组的实现"><a href="#未优化代码：二维数组的实现" class="headerlink" title="未优化代码：二维数组的实现"></a>未优化代码：二维数组的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 1e3 + 7;</div><div class="line">int n,v;</div><div class="line">int w[maxn],value[maxn];</div><div class="line">int dp[maxn][maxn];</div><div class="line">int mian()</div><div class="line">&#123;</div><div class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;v))</div><div class="line">	&#123;</div><div class="line">		memset(w,0,sizeof(w));</div><div class="line">		memset(value,0,sizeof(value));</div><div class="line">		memset(dp,0,sizeof(dp));</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;value[i]);</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++)</div><div class="line">		&#123;</div><div class="line">			for(int j = v; j &gt;= 0; --j)</div><div class="line">			&#123;</div><div class="line">				if(j &gt;= w[i])</div><div class="line">				    dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+value[i]);</div><div class="line">				else</div><div class="line">				    dp[i][j] = dp[i-1][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;,dp[n][v]);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化版本，一维数组实现"><a href="#优化版本，一维数组实现" class="headerlink" title="优化版本，一维数组实现"></a>优化版本，一维数组实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line">using namespace std;</div><div class="line">const int maxn = 1e3 + 7;</div><div class="line">int n,v;</div><div class="line">int w[maxn],value[maxn];</div><div class="line">int dp[maxn];</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;v))</div><div class="line">	&#123;</div><div class="line">		memset(w,0,sizeof(w));</div><div class="line">		memset(value,0,sizeof(value));</div><div class="line">		memset(dp,0,sizeof(dp));</div><div class="line">		for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;value[i]);</div><div class="line"></div><div class="line">		for(int i = 1; i &lt;= n; i++)</div><div class="line">		    for(int j = v; j &gt;= w[i]; --j)</div><div class="line">		        dp[j] = max(dp[j],dp[j-w[i]]+value[i]);</div><div class="line">		//体积为 j 的背包容纳的最大价值。</div><div class="line">		//体积为 j - w[i] 的背包容纳的最大价值。</div><div class="line">		printf(&quot;%d\n&quot;,dp[v]);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="动态规划一般的解题三部曲"><a href="#动态规划一般的解题三部曲" class="headerlink" title="动态规划一般的解题三部曲"></a>动态规划一般的解题三部曲</h1><h2 id="确定状态-1"><a href="#确定状态-1" class="headerlink" title="确定状态"></a>确定状态</h2><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><h2 id="确定编码实现方式-1"><a href="#确定编码实现方式-1" class="headerlink" title="确定编码实现方式"></a>确定编码实现方式</h2>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC打铁记</title>
    <url>/2019/11/18/ICPC%E6%89%93%E9%93%81/</url>
    <content><![CDATA[<h1 id="十一月十六"><a href="#十一月十六" class="headerlink" title="十一月十六"></a>十一月十六</h1><p> 沈阳的十一月大雪过后已是寒风凛至,头天马<br> 哥和王哥带俺去东北大学报道，报道结束,已<br> 经是上午十一点过,然后我提议去食堂觅食，<br> 然后我们就径直前去食堂。饭后，马哥的朋友<br> 带我们去寻找空教室休息。东大是我第一次在<br> 大学里看到拥有人脸支付功能的售货机。在这<br> 里点评东大的饭是真的好吃,本来这次打算和<br> 周哥他们见一面,后来想想，日后有缘自会相<br> 见。最后热生赛后我们一起去吃晚饭，然后回<br> 校。</p>
<h1 id="十一月十七"><a href="#十一月十七" class="headerlink" title="十一月十七"></a>十一月十七</h1><p> 正式赛那天早晨我很心慌,这一切来源我数学<br> 没看完,只把算法基础课的数学部分全部看完<br> 以及好好研究了一下博弈类型的题,然后把毛<br> 毛雨学姐发给我的数学看了一部分,正式赛中<br> 我发现我的问题,我发现平时思维题做多了,<br> 现在就只习惯思维题。ICPC我认识到自己是真<br> 的菜,在明年的省赛，蓝桥杯以及四省赛前我<br> 要提升自己，从一个量变到质变的过程。那晚<br> 我想了一晚上,我不能让”双非”成为我这一生<br> 的痛点，我要考研。考往西安电子科技大学，<br> 如果问我为什么不回成都呢？答案很简单，<br> 我向往自由，对于找对象这件事我现在没什<br> 么兴趣了，一切随缘。对于我两次高考的失败<br> 其实我早已意识到自己存在的毛病,但是我却<br> 一直逃避。做事情一旦遇见外界的干扰我就选<br> 择放弃，然后自嘲”自己时运不济，老天喜欢<br> 和我开玩笑”,其实如果当初我自律,现在我至<br> 少在读大三，不用为未来担忧。现在以及未来<br> 我要做我自己，他人用什么态度对待我,我将<br> 以什么态度对待他人。也许我会很高冷，也许<br> 让人看不懂，拥有自己的棱角。在此，感谢马<br> 哥和王哥带我一起去参加ICPC。未来在算法竞<br> 赛这条路上不拿牌子我不甘心，至少在省赛和<br> 东北四省赛中取得牌子，惟愿我能找到我的快<br> 乐。</p>
]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>感谢岁月</tag>
      </tags>
  </entry>
</search>
